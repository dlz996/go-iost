// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rpc/pb/rpc.proto

package rpcpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The enumeration defines transaction receipt status code.
type TxReceipt_StatusCode int32

const (
	// success
	TxReceipt_SUCCESS TxReceipt_StatusCode = 0
	// run out of gas
	TxReceipt_GAS_RUN_OUT TxReceipt_StatusCode = 1
	// balance not enough
	TxReceipt_BALANCE_NOT_ENOUGH TxReceipt_StatusCode = 2
	// wrong parameter
	TxReceipt_WRONG_PARAMETER TxReceipt_StatusCode = 3
	// runtime error
	TxReceipt_RUNTIME_ERROR TxReceipt_StatusCode = 4
	// run out of time
	TxReceipt_TIMEOUT TxReceipt_StatusCode = 5
	// wrong transaction format
	TxReceipt_WRONG_TX_FORMAT TxReceipt_StatusCode = 6
	// more than one set code action in a transaction
	TxReceipt_DUPLICATE_SET_CODE TxReceipt_StatusCode = 7
	// unknown error
	TxReceipt_UNKNOWN_ERROR TxReceipt_StatusCode = 8
)

var TxReceipt_StatusCode_name = map[int32]string{
	0: "SUCCESS",
	1: "GAS_RUN_OUT",
	2: "BALANCE_NOT_ENOUGH",
	3: "WRONG_PARAMETER",
	4: "RUNTIME_ERROR",
	5: "TIMEOUT",
	6: "WRONG_TX_FORMAT",
	7: "DUPLICATE_SET_CODE",
	8: "UNKNOWN_ERROR",
}
var TxReceipt_StatusCode_value = map[string]int32{
	"SUCCESS":            0,
	"GAS_RUN_OUT":        1,
	"BALANCE_NOT_ENOUGH": 2,
	"WRONG_PARAMETER":    3,
	"RUNTIME_ERROR":      4,
	"TIMEOUT":            5,
	"WRONG_TX_FORMAT":    6,
	"DUPLICATE_SET_CODE": 7,
	"UNKNOWN_ERROR":      8,
}

func (x TxReceipt_StatusCode) String() string {
	return proto.EnumName(TxReceipt_StatusCode_name, int32(x))
}
func (TxReceipt_StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{6, 0}
}

// The enumeration defines transaction status.
type TransactionResponse_Status int32

const (
	// pending in transaction pool
	TransactionResponse_PENDIND TransactionResponse_Status = 0
	// packed in a block that has not been confirmed
	TransactionResponse_PACKED TransactionResponse_Status = 1
	// packed in a block that is irreversible
	TransactionResponse_IRREVERSIBLE TransactionResponse_Status = 2
)

var TransactionResponse_Status_name = map[int32]string{
	0: "PENDIND",
	1: "PACKED",
	2: "IRREVERSIBLE",
}
var TransactionResponse_Status_value = map[string]int32{
	"PENDIND":      0,
	"PACKED":       1,
	"IRREVERSIBLE": 2,
}

func (x TransactionResponse_Status) String() string {
	return proto.EnumName(TransactionResponse_Status_name, int32(x))
}
func (TransactionResponse_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{8, 0}
}

// The enumeration defines the signature algorithm.
type Signature_Algorithm int32

const (
	// unknown
	Signature_UNKNOWN Signature_Algorithm = 0
	// secp256k1
	Signature_SECP256K1 Signature_Algorithm = 1
	// ed25519
	Signature_ED25519 Signature_Algorithm = 2
)

var Signature_Algorithm_name = map[int32]string{
	0: "UNKNOWN",
	1: "SECP256K1",
	2: "ED25519",
}
var Signature_Algorithm_value = map[string]int32{
	"UNKNOWN":   0,
	"SECP256K1": 1,
	"ED25519":   2,
}

func (x Signature_Algorithm) String() string {
	return proto.EnumName(Signature_Algorithm_name, int32(x))
}
func (Signature_Algorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{9, 0}
}

// The enumeration defines block status.
type BlockResponse_Status int32

const (
	// pending in block cache
	BlockResponse_PENDIND BlockResponse_Status = 0
	// irreversible
	BlockResponse_IRREVERSIBLE BlockResponse_Status = 1
)

var BlockResponse_Status_name = map[int32]string{
	0: "PENDIND",
	1: "IRREVERSIBLE",
}
var BlockResponse_Status_value = map[string]int32{
	"PENDIND":      0,
	"IRREVERSIBLE": 1,
}

func (x BlockResponse_Status) String() string {
	return proto.EnumName(BlockResponse_Status_name, int32(x))
}
func (BlockResponse_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{12, 0}
}

// The message defines an empty request.
type EmptyRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmptyRequest) Reset()         { *m = EmptyRequest{} }
func (m *EmptyRequest) String() string { return proto.CompactTextString(m) }
func (*EmptyRequest) ProtoMessage()    {}
func (*EmptyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{0}
}
func (m *EmptyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmptyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmptyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EmptyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmptyRequest.Merge(dst, src)
}
func (m *EmptyRequest) XXX_Size() int {
	return m.Size()
}
func (m *EmptyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EmptyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EmptyRequest proto.InternalMessageInfo

// The message defines peer information.
type PeerInfo struct {
	// peer ID
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// peer addr
	Addr                 string   `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PeerInfo) Reset()         { *m = PeerInfo{} }
func (m *PeerInfo) String() string { return proto.CompactTextString(m) }
func (*PeerInfo) ProtoMessage()    {}
func (*PeerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{1}
}
func (m *PeerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PeerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerInfo.Merge(dst, src)
}
func (m *PeerInfo) XXX_Size() int {
	return m.Size()
}
func (m *PeerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PeerInfo proto.InternalMessageInfo

func (m *PeerInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PeerInfo) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

// The message defines network connection information.
type NetworkInfo struct {
	// local network ID
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// peer connection count
	PeerCount int32 `protobuf:"varint,2,opt,name=peer_count,json=peerCount,proto3" json:"peer_count,omitempty"`
	// peers' information
	PeerInfo             []*PeerInfo `protobuf:"bytes,3,rep,name=peer_info,json=peerInfo" json:"peer_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *NetworkInfo) Reset()         { *m = NetworkInfo{} }
func (m *NetworkInfo) String() string { return proto.CompactTextString(m) }
func (*NetworkInfo) ProtoMessage()    {}
func (*NetworkInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{2}
}
func (m *NetworkInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NetworkInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInfo.Merge(dst, src)
}
func (m *NetworkInfo) XXX_Size() int {
	return m.Size()
}
func (m *NetworkInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInfo proto.InternalMessageInfo

func (m *NetworkInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NetworkInfo) GetPeerCount() int32 {
	if m != nil {
		return m.PeerCount
	}
	return 0
}

func (m *NetworkInfo) GetPeerInfo() []*PeerInfo {
	if m != nil {
		return m.PeerInfo
	}
	return nil
}

// The message containing the node's information.
type NodeInfoResponse struct {
	// build time
	BuildTime string `protobuf:"bytes,1,opt,name=build_time,json=buildTime,proto3" json:"build_time,omitempty"`
	// git hash
	GitHash string `protobuf:"bytes,2,opt,name=git_hash,json=gitHash,proto3" json:"git_hash,omitempty"`
	// node mode
	Mode string `protobuf:"bytes,3,opt,name=mode,proto3" json:"mode,omitempty"`
	// network connection information
	Network              *NetworkInfo `protobuf:"bytes,4,opt,name=network" json:"network,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *NodeInfoResponse) Reset()         { *m = NodeInfoResponse{} }
func (m *NodeInfoResponse) String() string { return proto.CompactTextString(m) }
func (*NodeInfoResponse) ProtoMessage()    {}
func (*NodeInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{3}
}
func (m *NodeInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NodeInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfoResponse.Merge(dst, src)
}
func (m *NodeInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfoResponse proto.InternalMessageInfo

func (m *NodeInfoResponse) GetBuildTime() string {
	if m != nil {
		return m.BuildTime
	}
	return ""
}

func (m *NodeInfoResponse) GetGitHash() string {
	if m != nil {
		return m.GitHash
	}
	return ""
}

func (m *NodeInfoResponse) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *NodeInfoResponse) GetNetwork() *NetworkInfo {
	if m != nil {
		return m.Network
	}
	return nil
}

// The message defines transaction amount limit struct.
type AmountLimit struct {
	// token name
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// limit value
	Value                float64  `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AmountLimit) Reset()         { *m = AmountLimit{} }
func (m *AmountLimit) String() string { return proto.CompactTextString(m) }
func (*AmountLimit) ProtoMessage()    {}
func (*AmountLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{4}
}
func (m *AmountLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AmountLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AmountLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AmountLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AmountLimit.Merge(dst, src)
}
func (m *AmountLimit) XXX_Size() int {
	return m.Size()
}
func (m *AmountLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_AmountLimit.DiscardUnknown(m)
}

var xxx_messageInfo_AmountLimit proto.InternalMessageInfo

func (m *AmountLimit) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AmountLimit) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// The message defines transaction action struct.
type Action struct {
	// contract name
	Contract string `protobuf:"bytes,1,opt,name=contract,proto3" json:"contract,omitempty"`
	// action name
	ActionName string `protobuf:"bytes,2,opt,name=action_name,json=actionName,proto3" json:"action_name,omitempty"`
	// data
	Data                 string   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Action) Reset()         { *m = Action{} }
func (m *Action) String() string { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()    {}
func (*Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{5}
}
func (m *Action) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Action.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action.Merge(dst, src)
}
func (m *Action) XXX_Size() int {
	return m.Size()
}
func (m *Action) XXX_DiscardUnknown() {
	xxx_messageInfo_Action.DiscardUnknown(m)
}

var xxx_messageInfo_Action proto.InternalMessageInfo

func (m *Action) GetContract() string {
	if m != nil {
		return m.Contract
	}
	return ""
}

func (m *Action) GetActionName() string {
	if m != nil {
		return m.ActionName
	}
	return ""
}

func (m *Action) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// The message defines the transaction receipt struct.
type TxReceipt struct {
	// transaction hash
	TxHash string `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	// gas usage
	GasUsage float64 `protobuf:"fixed64,2,opt,name=gas_usage,json=gasUsage,proto3" json:"gas_usage,omitempty"`
	// ram usage
	RamUsage map[string]int64 `protobuf:"bytes,3,rep,name=ram_usage,json=ramUsage" json:"ram_usage,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// status code
	StatusCode TxReceipt_StatusCode `protobuf:"varint,4,opt,name=status_code,json=statusCode,proto3,enum=rpcpb.TxReceipt_StatusCode" json:"status_code,omitempty"`
	// message
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// transaction returns
	Returns []string `protobuf:"bytes,6,rep,name=returns" json:"returns,omitempty"`
	// transaction receipts
	Receipts             []*TxReceipt_Receipt `protobuf:"bytes,7,rep,name=receipts" json:"receipts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TxReceipt) Reset()         { *m = TxReceipt{} }
func (m *TxReceipt) String() string { return proto.CompactTextString(m) }
func (*TxReceipt) ProtoMessage()    {}
func (*TxReceipt) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{6}
}
func (m *TxReceipt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxReceipt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxReceipt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxReceipt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxReceipt.Merge(dst, src)
}
func (m *TxReceipt) XXX_Size() int {
	return m.Size()
}
func (m *TxReceipt) XXX_DiscardUnknown() {
	xxx_messageInfo_TxReceipt.DiscardUnknown(m)
}

var xxx_messageInfo_TxReceipt proto.InternalMessageInfo

func (m *TxReceipt) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *TxReceipt) GetGasUsage() float64 {
	if m != nil {
		return m.GasUsage
	}
	return 0
}

func (m *TxReceipt) GetRamUsage() map[string]int64 {
	if m != nil {
		return m.RamUsage
	}
	return nil
}

func (m *TxReceipt) GetStatusCode() TxReceipt_StatusCode {
	if m != nil {
		return m.StatusCode
	}
	return TxReceipt_SUCCESS
}

func (m *TxReceipt) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *TxReceipt) GetReturns() []string {
	if m != nil {
		return m.Returns
	}
	return nil
}

func (m *TxReceipt) GetReceipts() []*TxReceipt_Receipt {
	if m != nil {
		return m.Receipts
	}
	return nil
}

// The message defines transaction execution receipt.
type TxReceipt_Receipt struct {
	// function name
	FuncName string `protobuf:"bytes,1,opt,name=func_name,json=funcName,proto3" json:"func_name,omitempty"`
	// content
	Content              string   `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxReceipt_Receipt) Reset()         { *m = TxReceipt_Receipt{} }
func (m *TxReceipt_Receipt) String() string { return proto.CompactTextString(m) }
func (*TxReceipt_Receipt) ProtoMessage()    {}
func (*TxReceipt_Receipt) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{6, 1}
}
func (m *TxReceipt_Receipt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxReceipt_Receipt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxReceipt_Receipt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxReceipt_Receipt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxReceipt_Receipt.Merge(dst, src)
}
func (m *TxReceipt_Receipt) XXX_Size() int {
	return m.Size()
}
func (m *TxReceipt_Receipt) XXX_DiscardUnknown() {
	xxx_messageInfo_TxReceipt_Receipt.DiscardUnknown(m)
}

var xxx_messageInfo_TxReceipt_Receipt proto.InternalMessageInfo

func (m *TxReceipt_Receipt) GetFuncName() string {
	if m != nil {
		return m.FuncName
	}
	return ""
}

func (m *TxReceipt_Receipt) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

// The message defines transaction struct.
type Transaction struct {
	// transaction hash
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// transaction timestamp
	Time int64 `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	// expiration timestamp
	Expiration int64 `protobuf:"varint,3,opt,name=expiration,proto3" json:"expiration,omitempty"`
	// gas gas_ratio
	GasRatio float64 `protobuf:"fixed64,4,opt,name=gas_ratio,json=gasRatio,proto3" json:"gas_ratio,omitempty"`
	// gas limit
	GasLimit float64 `protobuf:"fixed64,5,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	// delay nanoseconds
	Delay int64 `protobuf:"varint,6,opt,name=delay,proto3" json:"delay,omitempty"`
	// action list
	Actions []*Action `protobuf:"bytes,7,rep,name=actions" json:"actions,omitempty"`
	// signer list
	Signers []string `protobuf:"bytes,8,rep,name=signers" json:"signers,omitempty"`
	// publisher
	Publisher string `protobuf:"bytes,9,opt,name=publisher,proto3" json:"publisher,omitempty"`
	// referred transaction hash
	ReferredTx string `protobuf:"bytes,10,opt,name=referred_tx,json=referredTx,proto3" json:"referred_tx,omitempty"`
	// amount limit
	AmountLimit []*AmountLimit `protobuf:"bytes,11,rep,name=amount_limit,json=amountLimit" json:"amount_limit,omitempty"`
	// transaction receipt
	TxReceipt            *TxReceipt `protobuf:"bytes,12,opt,name=tx_receipt,json=txReceipt" json:"tx_receipt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Transaction) Reset()         { *m = Transaction{} }
func (m *Transaction) String() string { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()    {}
func (*Transaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{7}
}
func (m *Transaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Transaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transaction.Merge(dst, src)
}
func (m *Transaction) XXX_Size() int {
	return m.Size()
}
func (m *Transaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Transaction.DiscardUnknown(m)
}

var xxx_messageInfo_Transaction proto.InternalMessageInfo

func (m *Transaction) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Transaction) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Transaction) GetExpiration() int64 {
	if m != nil {
		return m.Expiration
	}
	return 0
}

func (m *Transaction) GetGasRatio() float64 {
	if m != nil {
		return m.GasRatio
	}
	return 0
}

func (m *Transaction) GetGasLimit() float64 {
	if m != nil {
		return m.GasLimit
	}
	return 0
}

func (m *Transaction) GetDelay() int64 {
	if m != nil {
		return m.Delay
	}
	return 0
}

func (m *Transaction) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *Transaction) GetSigners() []string {
	if m != nil {
		return m.Signers
	}
	return nil
}

func (m *Transaction) GetPublisher() string {
	if m != nil {
		return m.Publisher
	}
	return ""
}

func (m *Transaction) GetReferredTx() string {
	if m != nil {
		return m.ReferredTx
	}
	return ""
}

func (m *Transaction) GetAmountLimit() []*AmountLimit {
	if m != nil {
		return m.AmountLimit
	}
	return nil
}

func (m *Transaction) GetTxReceipt() *TxReceipt {
	if m != nil {
		return m.TxReceipt
	}
	return nil
}

// The message defines transaction response.
type TransactionResponse struct {
	// transaction status
	Status TransactionResponse_Status `protobuf:"varint,1,opt,name=status,proto3,enum=rpcpb.TransactionResponse_Status" json:"status,omitempty"`
	// transaction
	Transaction          *Transaction `protobuf:"bytes,2,opt,name=transaction" json:"transaction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TransactionResponse) Reset()         { *m = TransactionResponse{} }
func (m *TransactionResponse) String() string { return proto.CompactTextString(m) }
func (*TransactionResponse) ProtoMessage()    {}
func (*TransactionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{8}
}
func (m *TransactionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TransactionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionResponse.Merge(dst, src)
}
func (m *TransactionResponse) XXX_Size() int {
	return m.Size()
}
func (m *TransactionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionResponse proto.InternalMessageInfo

func (m *TransactionResponse) GetStatus() TransactionResponse_Status {
	if m != nil {
		return m.Status
	}
	return TransactionResponse_PENDIND
}

func (m *TransactionResponse) GetTransaction() *Transaction {
	if m != nil {
		return m.Transaction
	}
	return nil
}

// The message defines signature struct.
type Signature struct {
	// signature algorithm
	Algorithm Signature_Algorithm `protobuf:"varint,1,opt,name=algorithm,proto3,enum=rpcpb.Signature_Algorithm" json:"algorithm,omitempty"`
	// signature bytes
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	// public key
	PublicKey            []byte   `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{9}
}
func (m *Signature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(dst, src)
}
func (m *Signature) XXX_Size() int {
	return m.Size()
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

func (m *Signature) GetAlgorithm() Signature_Algorithm {
	if m != nil {
		return m.Algorithm
	}
	return Signature_UNKNOWN
}

func (m *Signature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Signature) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

// The message defines the transaction request.
type TransactionRequest struct {
	// transaction timestamp
	Time int64 `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	// expiration timestamp
	Expiration int64 `protobuf:"varint,2,opt,name=expiration,proto3" json:"expiration,omitempty"`
	// gas price
	GasRatio float64 `protobuf:"fixed64,3,opt,name=gas_ratio,json=gasRatio,proto3" json:"gas_ratio,omitempty"`
	// gas limit
	GasLimit float64 `protobuf:"fixed64,4,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	// delay nanoseconds
	Delay int64 `protobuf:"varint,5,opt,name=delay,proto3" json:"delay,omitempty"`
	// action list
	Actions []*Action `protobuf:"bytes,6,rep,name=actions" json:"actions,omitempty"`
	// amount limit
	AmountLimit []*AmountLimit `protobuf:"bytes,7,rep,name=amount_limit,json=amountLimit" json:"amount_limit,omitempty"`
	// signer list
	Signers []string `protobuf:"bytes,8,rep,name=signers" json:"signers,omitempty"`
	// signatures of signers
	Signatures []*Signature `protobuf:"bytes,9,rep,name=signatures" json:"signatures,omitempty"`
	// publisher
	Publisher string `protobuf:"bytes,10,opt,name=publisher,proto3" json:"publisher,omitempty"`
	// signatures of publisher
	PublisherSigs        []*Signature `protobuf:"bytes,11,rep,name=publisher_sigs,json=publisherSigs" json:"publisher_sigs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TransactionRequest) Reset()         { *m = TransactionRequest{} }
func (m *TransactionRequest) String() string { return proto.CompactTextString(m) }
func (*TransactionRequest) ProtoMessage()    {}
func (*TransactionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{10}
}
func (m *TransactionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TransactionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionRequest.Merge(dst, src)
}
func (m *TransactionRequest) XXX_Size() int {
	return m.Size()
}
func (m *TransactionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionRequest proto.InternalMessageInfo

func (m *TransactionRequest) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *TransactionRequest) GetExpiration() int64 {
	if m != nil {
		return m.Expiration
	}
	return 0
}

func (m *TransactionRequest) GetGasRatio() float64 {
	if m != nil {
		return m.GasRatio
	}
	return 0
}

func (m *TransactionRequest) GetGasLimit() float64 {
	if m != nil {
		return m.GasLimit
	}
	return 0
}

func (m *TransactionRequest) GetDelay() int64 {
	if m != nil {
		return m.Delay
	}
	return 0
}

func (m *TransactionRequest) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *TransactionRequest) GetAmountLimit() []*AmountLimit {
	if m != nil {
		return m.AmountLimit
	}
	return nil
}

func (m *TransactionRequest) GetSigners() []string {
	if m != nil {
		return m.Signers
	}
	return nil
}

func (m *TransactionRequest) GetSignatures() []*Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *TransactionRequest) GetPublisher() string {
	if m != nil {
		return m.Publisher
	}
	return ""
}

func (m *TransactionRequest) GetPublisherSigs() []*Signature {
	if m != nil {
		return m.PublisherSigs
	}
	return nil
}

// The message defines the block struct.
type Block struct {
	// block hash
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// block version
	Version int64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	// parent block hash
	ParentHash string `protobuf:"bytes,3,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	// transaction merkle tree root hash
	TxMerkleHash string `protobuf:"bytes,4,opt,name=tx_merkle_hash,json=txMerkleHash,proto3" json:"tx_merkle_hash,omitempty"`
	// transaction receipt merkle tree root hash
	TxReceiptMerkleHash string `protobuf:"bytes,5,opt,name=tx_receipt_merkle_hash,json=txReceiptMerkleHash,proto3" json:"tx_receipt_merkle_hash,omitempty"`
	// block number
	Number int64 `protobuf:"varint,6,opt,name=number,proto3" json:"number,omitempty"`
	// block producer witness
	Witness string `protobuf:"bytes,7,opt,name=witness,proto3" json:"witness,omitempty"`
	// block timestamp
	Time int64 `protobuf:"varint,8,opt,name=time,proto3" json:"time,omitempty"`
	// block gas usage
	GasUsage float64 `protobuf:"fixed64,9,opt,name=gas_usage,json=gasUsage,proto3" json:"gas_usage,omitempty"`
	// transaction count
	TxCount int64 `protobuf:"varint,10,opt,name=tx_count,json=txCount,proto3" json:"tx_count,omitempty"`
	// extra information
	Info *Block_Info `protobuf:"bytes,11,opt,name=info" json:"info,omitempty"`
	// block transactions
	Transactions         []*Transaction `protobuf:"bytes,12,rep,name=transactions" json:"transactions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Block) Reset()         { *m = Block{} }
func (m *Block) String() string { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()    {}
func (*Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{11}
}
func (m *Block) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block.Merge(dst, src)
}
func (m *Block) XXX_Size() int {
	return m.Size()
}
func (m *Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Block proto.InternalMessageInfo

func (m *Block) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Block) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Block) GetParentHash() string {
	if m != nil {
		return m.ParentHash
	}
	return ""
}

func (m *Block) GetTxMerkleHash() string {
	if m != nil {
		return m.TxMerkleHash
	}
	return ""
}

func (m *Block) GetTxReceiptMerkleHash() string {
	if m != nil {
		return m.TxReceiptMerkleHash
	}
	return ""
}

func (m *Block) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *Block) GetWitness() string {
	if m != nil {
		return m.Witness
	}
	return ""
}

func (m *Block) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Block) GetGasUsage() float64 {
	if m != nil {
		return m.GasUsage
	}
	return 0
}

func (m *Block) GetTxCount() int64 {
	if m != nil {
		return m.TxCount
	}
	return 0
}

func (m *Block) GetInfo() *Block_Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Block) GetTransactions() []*Transaction {
	if m != nil {
		return m.Transactions
	}
	return nil
}

// The message defines block extra information
type Block_Info struct {
	// pack mode
	Mode int32 `protobuf:"varint,1,opt,name=mode,proto3" json:"mode,omitempty"`
	// transaction execution thread number
	Thread int32 `protobuf:"varint,2,opt,name=thread,proto3" json:"thread,omitempty"`
	// transaction index of every batch execution
	BatchIndex           []int32  `protobuf:"varint,3,rep,packed,name=batch_index,json=batchIndex" json:"batch_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Block_Info) Reset()         { *m = Block_Info{} }
func (m *Block_Info) String() string { return proto.CompactTextString(m) }
func (*Block_Info) ProtoMessage()    {}
func (*Block_Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{11, 0}
}
func (m *Block_Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block_Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block_Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Block_Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block_Info.Merge(dst, src)
}
func (m *Block_Info) XXX_Size() int {
	return m.Size()
}
func (m *Block_Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Block_Info.DiscardUnknown(m)
}

var xxx_messageInfo_Block_Info proto.InternalMessageInfo

func (m *Block_Info) GetMode() int32 {
	if m != nil {
		return m.Mode
	}
	return 0
}

func (m *Block_Info) GetThread() int32 {
	if m != nil {
		return m.Thread
	}
	return 0
}

func (m *Block_Info) GetBatchIndex() []int32 {
	if m != nil {
		return m.BatchIndex
	}
	return nil
}

type BlockResponse struct {
	// transaction status
	Status BlockResponse_Status `protobuf:"varint,1,opt,name=status,proto3,enum=rpcpb.BlockResponse_Status" json:"status,omitempty"`
	// block
	Block                *Block   `protobuf:"bytes,2,opt,name=block" json:"block,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockResponse) Reset()         { *m = BlockResponse{} }
func (m *BlockResponse) String() string { return proto.CompactTextString(m) }
func (*BlockResponse) ProtoMessage()    {}
func (*BlockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{12}
}
func (m *BlockResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockResponse.Merge(dst, src)
}
func (m *BlockResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlockResponse proto.InternalMessageInfo

func (m *BlockResponse) GetStatus() BlockResponse_Status {
	if m != nil {
		return m.Status
	}
	return BlockResponse_PENDIND
}

func (m *BlockResponse) GetBlock() *Block {
	if m != nil {
		return m.Block
	}
	return nil
}

// The message defines chain information response.
type ChainInfoResponse struct {
	// the name of network, such mainnet or testnet
	NetName string `protobuf:"bytes,1,opt,name=net_name,json=netName,proto3" json:"net_name,omitempty"`
	// the iost protocol version
	ProtocolVersion string `protobuf:"bytes,2,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	// head block height
	HeadBlock int64 `protobuf:"varint,3,opt,name=head_block,json=headBlock,proto3" json:"head_block,omitempty"`
	// head block hash
	HeadBlockHash string `protobuf:"bytes,4,opt,name=head_block_hash,json=headBlockHash,proto3" json:"head_block_hash,omitempty"`
	// last irreversible block number
	LibBlock int64 `protobuf:"varint,5,opt,name=lib_block,json=libBlock,proto3" json:"lib_block,omitempty"`
	// last irreversible block hash
	LibBlockHash string `protobuf:"bytes,6,opt,name=lib_block_hash,json=libBlockHash,proto3" json:"lib_block_hash,omitempty"`
	// the current witness list
	WitnessList          []string `protobuf:"bytes,7,rep,name=witness_list,json=witnessList" json:"witness_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChainInfoResponse) Reset()         { *m = ChainInfoResponse{} }
func (m *ChainInfoResponse) String() string { return proto.CompactTextString(m) }
func (*ChainInfoResponse) ProtoMessage()    {}
func (*ChainInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{13}
}
func (m *ChainInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ChainInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainInfoResponse.Merge(dst, src)
}
func (m *ChainInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ChainInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ChainInfoResponse proto.InternalMessageInfo

func (m *ChainInfoResponse) GetNetName() string {
	if m != nil {
		return m.NetName
	}
	return ""
}

func (m *ChainInfoResponse) GetProtocolVersion() string {
	if m != nil {
		return m.ProtocolVersion
	}
	return ""
}

func (m *ChainInfoResponse) GetHeadBlock() int64 {
	if m != nil {
		return m.HeadBlock
	}
	return 0
}

func (m *ChainInfoResponse) GetHeadBlockHash() string {
	if m != nil {
		return m.HeadBlockHash
	}
	return ""
}

func (m *ChainInfoResponse) GetLibBlock() int64 {
	if m != nil {
		return m.LibBlock
	}
	return 0
}

func (m *ChainInfoResponse) GetLibBlockHash() string {
	if m != nil {
		return m.LibBlockHash
	}
	return ""
}

func (m *ChainInfoResponse) GetWitnessList() []string {
	if m != nil {
		return m.WitnessList
	}
	return nil
}

// The request message containing the tx's hash.
type TxHashRequest struct {
	// tx hash
	Hash                 string   `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxHashRequest) Reset()         { *m = TxHashRequest{} }
func (m *TxHashRequest) String() string { return proto.CompactTextString(m) }
func (*TxHashRequest) ProtoMessage()    {}
func (*TxHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{14}
}
func (m *TxHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxHashRequest.Merge(dst, src)
}
func (m *TxHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxHashRequest proto.InternalMessageInfo

func (m *TxHashRequest) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

// The request message containing the block's hash.
type GetBlockByHashRequest struct {
	// block hash
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// complete means whether including the full transactions and transaction receipts
	Complete             bool     `protobuf:"varint,2,opt,name=complete,proto3" json:"complete,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBlockByHashRequest) Reset()         { *m = GetBlockByHashRequest{} }
func (m *GetBlockByHashRequest) String() string { return proto.CompactTextString(m) }
func (*GetBlockByHashRequest) ProtoMessage()    {}
func (*GetBlockByHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{15}
}
func (m *GetBlockByHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlockByHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlockByHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetBlockByHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlockByHashRequest.Merge(dst, src)
}
func (m *GetBlockByHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBlockByHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlockByHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlockByHashRequest proto.InternalMessageInfo

func (m *GetBlockByHashRequest) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *GetBlockByHashRequest) GetComplete() bool {
	if m != nil {
		return m.Complete
	}
	return false
}

// The request message containing the block's number.
type GetBlockByNumberRequest struct {
	// block number
	Number int64 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	// complete means whether including the full transactions and transaction receipts
	Complete             bool     `protobuf:"varint,2,opt,name=complete,proto3" json:"complete,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBlockByNumberRequest) Reset()         { *m = GetBlockByNumberRequest{} }
func (m *GetBlockByNumberRequest) String() string { return proto.CompactTextString(m) }
func (*GetBlockByNumberRequest) ProtoMessage()    {}
func (*GetBlockByNumberRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{16}
}
func (m *GetBlockByNumberRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlockByNumberRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlockByNumberRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetBlockByNumberRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlockByNumberRequest.Merge(dst, src)
}
func (m *GetBlockByNumberRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBlockByNumberRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlockByNumberRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlockByNumberRequest proto.InternalMessageInfo

func (m *GetBlockByNumberRequest) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *GetBlockByNumberRequest) GetComplete() bool {
	if m != nil {
		return m.Complete
	}
	return false
}

// The message defines the account's frozen balance.
type FrozenBalance struct {
	// balance amount
	Amount float64 `protobuf:"fixed64,1,opt,name=amount,proto3" json:"amount,omitempty"`
	// free time
	Time                 int64    `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FrozenBalance) Reset()         { *m = FrozenBalance{} }
func (m *FrozenBalance) String() string { return proto.CompactTextString(m) }
func (*FrozenBalance) ProtoMessage()    {}
func (*FrozenBalance) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{17}
}
func (m *FrozenBalance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FrozenBalance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FrozenBalance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FrozenBalance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FrozenBalance.Merge(dst, src)
}
func (m *FrozenBalance) XXX_Size() int {
	return m.Size()
}
func (m *FrozenBalance) XXX_DiscardUnknown() {
	xxx_messageInfo_FrozenBalance.DiscardUnknown(m)
}

var xxx_messageInfo_FrozenBalance proto.InternalMessageInfo

func (m *FrozenBalance) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *FrozenBalance) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

// The message defines account struct.
type Account struct {
	// account name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// account balance
	Balance float64 `protobuf:"fixed64,2,opt,name=balance,proto3" json:"balance,omitempty"`
	// account create timestamp
	CreateTime int64 `protobuf:"varint,3,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// gas information
	GasInfo *Account_GasInfo `protobuf:"bytes,4,opt,name=gas_info,json=gasInfo" json:"gas_info,omitempty"`
	// ram information
	RamInfo *Account_RAMInfo `protobuf:"bytes,5,opt,name=ram_info,json=ramInfo" json:"ram_info,omitempty"`
	// account permission
	Permissions map[string]*Account_Permission `protobuf:"bytes,6,rep,name=permissions" json:"permissions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// account groups
	Groups map[string]*Account_Group `protobuf:"bytes,7,rep,name=groups" json:"groups,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// frozen balance information
	FrozenBalances       []*FrozenBalance `protobuf:"bytes,8,rep,name=frozen_balances,json=frozenBalances" json:"frozen_balances,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Account) Reset()         { *m = Account{} }
func (m *Account) String() string { return proto.CompactTextString(m) }
func (*Account) ProtoMessage()    {}
func (*Account) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{18}
}
func (m *Account) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Account) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account.Merge(dst, src)
}
func (m *Account) XXX_Size() int {
	return m.Size()
}
func (m *Account) XXX_DiscardUnknown() {
	xxx_messageInfo_Account.DiscardUnknown(m)
}

var xxx_messageInfo_Account proto.InternalMessageInfo

func (m *Account) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Account) GetBalance() float64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *Account) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *Account) GetGasInfo() *Account_GasInfo {
	if m != nil {
		return m.GasInfo
	}
	return nil
}

func (m *Account) GetRamInfo() *Account_RAMInfo {
	if m != nil {
		return m.RamInfo
	}
	return nil
}

func (m *Account) GetPermissions() map[string]*Account_Permission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *Account) GetGroups() map[string]*Account_Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *Account) GetFrozenBalances() []*FrozenBalance {
	if m != nil {
		return m.FrozenBalances
	}
	return nil
}

// The message defines account pledged coin information.
type Account_PledgeInfo struct {
	// the account who pledges
	Pledger string `protobuf:"bytes,1,opt,name=pledger,proto3" json:"pledger,omitempty"`
	// pledged amount
	Amount               float64  `protobuf:"fixed64,2,opt,name=amount,proto3" json:"amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Account_PledgeInfo) Reset()         { *m = Account_PledgeInfo{} }
func (m *Account_PledgeInfo) String() string { return proto.CompactTextString(m) }
func (*Account_PledgeInfo) ProtoMessage()    {}
func (*Account_PledgeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{18, 0}
}
func (m *Account_PledgeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account_PledgeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account_PledgeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Account_PledgeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account_PledgeInfo.Merge(dst, src)
}
func (m *Account_PledgeInfo) XXX_Size() int {
	return m.Size()
}
func (m *Account_PledgeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_Account_PledgeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_Account_PledgeInfo proto.InternalMessageInfo

func (m *Account_PledgeInfo) GetPledger() string {
	if m != nil {
		return m.Pledger
	}
	return ""
}

func (m *Account_PledgeInfo) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

// The message defines account gas information.
type Account_GasInfo struct {
	// current total gas amount
	CurrentTotal    float64 `protobuf:"fixed64,1,opt,name=current_total,json=currentTotal,proto3" json:"current_total,omitempty"`
	TransferableGas float64 `protobuf:"fixed64,2,opt,name=transferable_gas,json=transferableGas,proto3" json:"transferable_gas,omitempty"`
	PledgeGas       float64 `protobuf:"fixed64,3,opt,name=pledge_gas,json=pledgeGas,proto3" json:"pledge_gas,omitempty"`
	// gas increase speed
	IncreaseSpeed float64 `protobuf:"fixed64,4,opt,name=increase_speed,json=increaseSpeed,proto3" json:"increase_speed,omitempty"`
	// gas limit
	Limit float64 `protobuf:"fixed64,5,opt,name=limit,proto3" json:"limit,omitempty"`
	// pledge information
	PledgedInfo          []*Account_PledgeInfo `protobuf:"bytes,6,rep,name=pledged_info,json=pledgedInfo" json:"pledged_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Account_GasInfo) Reset()         { *m = Account_GasInfo{} }
func (m *Account_GasInfo) String() string { return proto.CompactTextString(m) }
func (*Account_GasInfo) ProtoMessage()    {}
func (*Account_GasInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{18, 1}
}
func (m *Account_GasInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account_GasInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account_GasInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Account_GasInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account_GasInfo.Merge(dst, src)
}
func (m *Account_GasInfo) XXX_Size() int {
	return m.Size()
}
func (m *Account_GasInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_Account_GasInfo.DiscardUnknown(m)
}

var xxx_messageInfo_Account_GasInfo proto.InternalMessageInfo

func (m *Account_GasInfo) GetCurrentTotal() float64 {
	if m != nil {
		return m.CurrentTotal
	}
	return 0
}

func (m *Account_GasInfo) GetTransferableGas() float64 {
	if m != nil {
		return m.TransferableGas
	}
	return 0
}

func (m *Account_GasInfo) GetPledgeGas() float64 {
	if m != nil {
		return m.PledgeGas
	}
	return 0
}

func (m *Account_GasInfo) GetIncreaseSpeed() float64 {
	if m != nil {
		return m.IncreaseSpeed
	}
	return 0
}

func (m *Account_GasInfo) GetLimit() float64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *Account_GasInfo) GetPledgedInfo() []*Account_PledgeInfo {
	if m != nil {
		return m.PledgedInfo
	}
	return nil
}

// The message defines account ram information.
type Account_RAMInfo struct {
	// available ram bytes
	Available            int64    `protobuf:"varint,1,opt,name=available,proto3" json:"available,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Account_RAMInfo) Reset()         { *m = Account_RAMInfo{} }
func (m *Account_RAMInfo) String() string { return proto.CompactTextString(m) }
func (*Account_RAMInfo) ProtoMessage()    {}
func (*Account_RAMInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{18, 2}
}
func (m *Account_RAMInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account_RAMInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account_RAMInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Account_RAMInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account_RAMInfo.Merge(dst, src)
}
func (m *Account_RAMInfo) XXX_Size() int {
	return m.Size()
}
func (m *Account_RAMInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_Account_RAMInfo.DiscardUnknown(m)
}

var xxx_messageInfo_Account_RAMInfo proto.InternalMessageInfo

func (m *Account_RAMInfo) GetAvailable() int64 {
	if m != nil {
		return m.Available
	}
	return 0
}

// The message defines permission item.
type Account_Item struct {
	// permission name or key pair id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// whether it's a key pair
	IsKeyPair bool `protobuf:"varint,2,opt,name=is_key_pair,json=isKeyPair,proto3" json:"is_key_pair,omitempty"`
	// permission weight
	Weight int64 `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"`
	// permission
	Permission           string   `protobuf:"bytes,4,opt,name=permission,proto3" json:"permission,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Account_Item) Reset()         { *m = Account_Item{} }
func (m *Account_Item) String() string { return proto.CompactTextString(m) }
func (*Account_Item) ProtoMessage()    {}
func (*Account_Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{18, 3}
}
func (m *Account_Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account_Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Account_Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account_Item.Merge(dst, src)
}
func (m *Account_Item) XXX_Size() int {
	return m.Size()
}
func (m *Account_Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Account_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Account_Item proto.InternalMessageInfo

func (m *Account_Item) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Account_Item) GetIsKeyPair() bool {
	if m != nil {
		return m.IsKeyPair
	}
	return false
}

func (m *Account_Item) GetWeight() int64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *Account_Item) GetPermission() string {
	if m != nil {
		return m.Permission
	}
	return ""
}

// The message defines a permission group.
type Account_Group struct {
	// group name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// permission items
	Items                []*Account_Item `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Account_Group) Reset()         { *m = Account_Group{} }
func (m *Account_Group) String() string { return proto.CompactTextString(m) }
func (*Account_Group) ProtoMessage()    {}
func (*Account_Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{18, 4}
}
func (m *Account_Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account_Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Account_Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account_Group.Merge(dst, src)
}
func (m *Account_Group) XXX_Size() int {
	return m.Size()
}
func (m *Account_Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Account_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Account_Group proto.InternalMessageInfo

func (m *Account_Group) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Account_Group) GetItems() []*Account_Item {
	if m != nil {
		return m.Items
	}
	return nil
}

// The message defines the permission struct.
type Account_Permission struct {
	// permission name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// permission groups
	Groups []string `protobuf:"bytes,2,rep,name=groups" json:"groups,omitempty"`
	// permission items
	Items []*Account_Item `protobuf:"bytes,3,rep,name=items" json:"items,omitempty"`
	// permission threshold
	Threshold            int64    `protobuf:"varint,4,opt,name=threshold,proto3" json:"threshold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Account_Permission) Reset()         { *m = Account_Permission{} }
func (m *Account_Permission) String() string { return proto.CompactTextString(m) }
func (*Account_Permission) ProtoMessage()    {}
func (*Account_Permission) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{18, 5}
}
func (m *Account_Permission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account_Permission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account_Permission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Account_Permission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account_Permission.Merge(dst, src)
}
func (m *Account_Permission) XXX_Size() int {
	return m.Size()
}
func (m *Account_Permission) XXX_DiscardUnknown() {
	xxx_messageInfo_Account_Permission.DiscardUnknown(m)
}

var xxx_messageInfo_Account_Permission proto.InternalMessageInfo

func (m *Account_Permission) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Account_Permission) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *Account_Permission) GetItems() []*Account_Item {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Account_Permission) GetThreshold() int64 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

// The message defines the get account request.
type GetAccountRequest struct {
	// account name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// get account by longest chain's head block or last irreversible block
	ByLongestChain       bool     `protobuf:"varint,2,opt,name=by_longest_chain,json=byLongestChain,proto3" json:"by_longest_chain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAccountRequest) Reset()         { *m = GetAccountRequest{} }
func (m *GetAccountRequest) String() string { return proto.CompactTextString(m) }
func (*GetAccountRequest) ProtoMessage()    {}
func (*GetAccountRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{19}
}
func (m *GetAccountRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAccountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAccountRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetAccountRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAccountRequest.Merge(dst, src)
}
func (m *GetAccountRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAccountRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAccountRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAccountRequest proto.InternalMessageInfo

func (m *GetAccountRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetAccountRequest) GetByLongestChain() bool {
	if m != nil {
		return m.ByLongestChain
	}
	return false
}

// The message defines the contract struct.
type Contract struct {
	// contract id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// contract code
	Code string `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	// contract language
	Language string `protobuf:"bytes,3,opt,name=language,proto3" json:"language,omitempty"`
	// contract version
	Version string `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	// contract abis
	Abis                 []*Contract_ABI `protobuf:"bytes,5,rep,name=abis" json:"abis,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Contract) Reset()         { *m = Contract{} }
func (m *Contract) String() string { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()    {}
func (*Contract) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{20}
}
func (m *Contract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Contract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Contract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Contract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contract.Merge(dst, src)
}
func (m *Contract) XXX_Size() int {
	return m.Size()
}
func (m *Contract) XXX_DiscardUnknown() {
	xxx_messageInfo_Contract.DiscardUnknown(m)
}

var xxx_messageInfo_Contract proto.InternalMessageInfo

func (m *Contract) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Contract) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Contract) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Contract) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Contract) GetAbis() []*Contract_ABI {
	if m != nil {
		return m.Abis
	}
	return nil
}

// The message defines the ABI struct.
type Contract_ABI struct {
	// abi name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// abi arguments
	Args []string `protobuf:"bytes,2,rep,name=args" json:"args,omitempty"`
	// abi amount limt
	AmountLimit          []*AmountLimit `protobuf:"bytes,3,rep,name=amount_limit,json=amountLimit" json:"amount_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Contract_ABI) Reset()         { *m = Contract_ABI{} }
func (m *Contract_ABI) String() string { return proto.CompactTextString(m) }
func (*Contract_ABI) ProtoMessage()    {}
func (*Contract_ABI) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{20, 0}
}
func (m *Contract_ABI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Contract_ABI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Contract_ABI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Contract_ABI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contract_ABI.Merge(dst, src)
}
func (m *Contract_ABI) XXX_Size() int {
	return m.Size()
}
func (m *Contract_ABI) XXX_DiscardUnknown() {
	xxx_messageInfo_Contract_ABI.DiscardUnknown(m)
}

var xxx_messageInfo_Contract_ABI proto.InternalMessageInfo

func (m *Contract_ABI) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Contract_ABI) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Contract_ABI) GetAmountLimit() []*AmountLimit {
	if m != nil {
		return m.AmountLimit
	}
	return nil
}

// The message defines get contract request.
type GetContractRequest struct {
	// contract id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// get data by longest chain's head block or last irreversible block
	ByLongestChain       bool     `protobuf:"varint,2,opt,name=by_longest_chain,json=byLongestChain,proto3" json:"by_longest_chain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetContractRequest) Reset()         { *m = GetContractRequest{} }
func (m *GetContractRequest) String() string { return proto.CompactTextString(m) }
func (*GetContractRequest) ProtoMessage()    {}
func (*GetContractRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{21}
}
func (m *GetContractRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetContractRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetContractRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetContractRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetContractRequest.Merge(dst, src)
}
func (m *GetContractRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetContractRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetContractRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetContractRequest proto.InternalMessageInfo

func (m *GetContractRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GetContractRequest) GetByLongestChain() bool {
	if m != nil {
		return m.ByLongestChain
	}
	return false
}

// The message defines get contract storage request.
type GetContractStorageRequest struct {
	// contract id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// the key in the StateDB
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// get the value from StateDB, field is needed if StateDB[key] is a map.(we get StateDB[key][field] in this case)
	Field string `protobuf:"bytes,3,opt,name=field,proto3" json:"field,omitempty"`
	// get data by longest chain's head block or last irreversible block
	ByLongestChain       bool     `protobuf:"varint,4,opt,name=by_longest_chain,json=byLongestChain,proto3" json:"by_longest_chain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetContractStorageRequest) Reset()         { *m = GetContractStorageRequest{} }
func (m *GetContractStorageRequest) String() string { return proto.CompactTextString(m) }
func (*GetContractStorageRequest) ProtoMessage()    {}
func (*GetContractStorageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{22}
}
func (m *GetContractStorageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetContractStorageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetContractStorageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetContractStorageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetContractStorageRequest.Merge(dst, src)
}
func (m *GetContractStorageRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetContractStorageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetContractStorageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetContractStorageRequest proto.InternalMessageInfo

func (m *GetContractStorageRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GetContractStorageRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *GetContractStorageRequest) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *GetContractStorageRequest) GetByLongestChain() bool {
	if m != nil {
		return m.ByLongestChain
	}
	return false
}

// The message defines get contract storage response.
type GetContractStorageResponse struct {
	// the json string data
	Data                 string   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetContractStorageResponse) Reset()         { *m = GetContractStorageResponse{} }
func (m *GetContractStorageResponse) String() string { return proto.CompactTextString(m) }
func (*GetContractStorageResponse) ProtoMessage()    {}
func (*GetContractStorageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{23}
}
func (m *GetContractStorageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetContractStorageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetContractStorageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetContractStorageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetContractStorageResponse.Merge(dst, src)
}
func (m *GetContractStorageResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetContractStorageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetContractStorageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetContractStorageResponse proto.InternalMessageInfo

func (m *GetContractStorageResponse) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// The message defines send transaction response.
type SendTransactionResponse struct {
	// the final transaction hash
	Hash                 string   `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendTransactionResponse) Reset()         { *m = SendTransactionResponse{} }
func (m *SendTransactionResponse) String() string { return proto.CompactTextString(m) }
func (*SendTransactionResponse) ProtoMessage()    {}
func (*SendTransactionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{24}
}
func (m *SendTransactionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendTransactionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendTransactionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SendTransactionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendTransactionResponse.Merge(dst, src)
}
func (m *SendTransactionResponse) XXX_Size() int {
	return m.Size()
}
func (m *SendTransactionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SendTransactionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SendTransactionResponse proto.InternalMessageInfo

func (m *SendTransactionResponse) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

// The message defines get token balance response.
type GetTokenBalanceResponse struct {
	// token balance
	Balance float64 `protobuf:"fixed64,1,opt,name=balance,proto3" json:"balance,omitempty"`
	// frozen balance information
	FrozenBalances       []*FrozenBalance `protobuf:"bytes,2,rep,name=frozen_balances,json=frozenBalances" json:"frozen_balances,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *GetTokenBalanceResponse) Reset()         { *m = GetTokenBalanceResponse{} }
func (m *GetTokenBalanceResponse) String() string { return proto.CompactTextString(m) }
func (*GetTokenBalanceResponse) ProtoMessage()    {}
func (*GetTokenBalanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{25}
}
func (m *GetTokenBalanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTokenBalanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTokenBalanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetTokenBalanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTokenBalanceResponse.Merge(dst, src)
}
func (m *GetTokenBalanceResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTokenBalanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTokenBalanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTokenBalanceResponse proto.InternalMessageInfo

func (m *GetTokenBalanceResponse) GetBalance() float64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *GetTokenBalanceResponse) GetFrozenBalances() []*FrozenBalance {
	if m != nil {
		return m.FrozenBalances
	}
	return nil
}

// The message defines get token balance request.
type GetTokenBalanceRequest struct {
	// account name
	Account string `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	// the token name
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	// get data by longest chain's head block or last irreversible block
	ByLongestChain       bool     `protobuf:"varint,3,opt,name=by_longest_chain,json=byLongestChain,proto3" json:"by_longest_chain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTokenBalanceRequest) Reset()         { *m = GetTokenBalanceRequest{} }
func (m *GetTokenBalanceRequest) String() string { return proto.CompactTextString(m) }
func (*GetTokenBalanceRequest) ProtoMessage()    {}
func (*GetTokenBalanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_rpc_5d6ef4678745fb9b, []int{26}
}
func (m *GetTokenBalanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTokenBalanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTokenBalanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetTokenBalanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTokenBalanceRequest.Merge(dst, src)
}
func (m *GetTokenBalanceRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTokenBalanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTokenBalanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTokenBalanceRequest proto.InternalMessageInfo

func (m *GetTokenBalanceRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *GetTokenBalanceRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *GetTokenBalanceRequest) GetByLongestChain() bool {
	if m != nil {
		return m.ByLongestChain
	}
	return false
}

func init() {
	proto.RegisterType((*EmptyRequest)(nil), "rpcpb.EmptyRequest")
	proto.RegisterType((*PeerInfo)(nil), "rpcpb.PeerInfo")
	proto.RegisterType((*NetworkInfo)(nil), "rpcpb.NetworkInfo")
	proto.RegisterType((*NodeInfoResponse)(nil), "rpcpb.NodeInfoResponse")
	proto.RegisterType((*AmountLimit)(nil), "rpcpb.AmountLimit")
	proto.RegisterType((*Action)(nil), "rpcpb.Action")
	proto.RegisterType((*TxReceipt)(nil), "rpcpb.TxReceipt")
	proto.RegisterMapType((map[string]int64)(nil), "rpcpb.TxReceipt.RamUsageEntry")
	proto.RegisterType((*TxReceipt_Receipt)(nil), "rpcpb.TxReceipt.Receipt")
	proto.RegisterType((*Transaction)(nil), "rpcpb.Transaction")
	proto.RegisterType((*TransactionResponse)(nil), "rpcpb.TransactionResponse")
	proto.RegisterType((*Signature)(nil), "rpcpb.Signature")
	proto.RegisterType((*TransactionRequest)(nil), "rpcpb.TransactionRequest")
	proto.RegisterType((*Block)(nil), "rpcpb.Block")
	proto.RegisterType((*Block_Info)(nil), "rpcpb.Block.Info")
	proto.RegisterType((*BlockResponse)(nil), "rpcpb.BlockResponse")
	proto.RegisterType((*ChainInfoResponse)(nil), "rpcpb.ChainInfoResponse")
	proto.RegisterType((*TxHashRequest)(nil), "rpcpb.TxHashRequest")
	proto.RegisterType((*GetBlockByHashRequest)(nil), "rpcpb.GetBlockByHashRequest")
	proto.RegisterType((*GetBlockByNumberRequest)(nil), "rpcpb.GetBlockByNumberRequest")
	proto.RegisterType((*FrozenBalance)(nil), "rpcpb.FrozenBalance")
	proto.RegisterType((*Account)(nil), "rpcpb.Account")
	proto.RegisterMapType((map[string]*Account_Group)(nil), "rpcpb.Account.GroupsEntry")
	proto.RegisterMapType((map[string]*Account_Permission)(nil), "rpcpb.Account.PermissionsEntry")
	proto.RegisterType((*Account_PledgeInfo)(nil), "rpcpb.Account.PledgeInfo")
	proto.RegisterType((*Account_GasInfo)(nil), "rpcpb.Account.GasInfo")
	proto.RegisterType((*Account_RAMInfo)(nil), "rpcpb.Account.RAMInfo")
	proto.RegisterType((*Account_Item)(nil), "rpcpb.Account.Item")
	proto.RegisterType((*Account_Group)(nil), "rpcpb.Account.Group")
	proto.RegisterType((*Account_Permission)(nil), "rpcpb.Account.Permission")
	proto.RegisterType((*GetAccountRequest)(nil), "rpcpb.GetAccountRequest")
	proto.RegisterType((*Contract)(nil), "rpcpb.Contract")
	proto.RegisterType((*Contract_ABI)(nil), "rpcpb.Contract.ABI")
	proto.RegisterType((*GetContractRequest)(nil), "rpcpb.GetContractRequest")
	proto.RegisterType((*GetContractStorageRequest)(nil), "rpcpb.GetContractStorageRequest")
	proto.RegisterType((*GetContractStorageResponse)(nil), "rpcpb.GetContractStorageResponse")
	proto.RegisterType((*SendTransactionResponse)(nil), "rpcpb.SendTransactionResponse")
	proto.RegisterType((*GetTokenBalanceResponse)(nil), "rpcpb.GetTokenBalanceResponse")
	proto.RegisterType((*GetTokenBalanceRequest)(nil), "rpcpb.GetTokenBalanceRequest")
	proto.RegisterEnum("rpcpb.TxReceipt_StatusCode", TxReceipt_StatusCode_name, TxReceipt_StatusCode_value)
	proto.RegisterEnum("rpcpb.TransactionResponse_Status", TransactionResponse_Status_name, TransactionResponse_Status_value)
	proto.RegisterEnum("rpcpb.Signature_Algorithm", Signature_Algorithm_name, Signature_Algorithm_value)
	proto.RegisterEnum("rpcpb.BlockResponse_Status", BlockResponse_Status_name, BlockResponse_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ApiServiceClient is the client API for ApiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ApiServiceClient interface {
	// get the node information
	GetNodeInfo(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*NodeInfoResponse, error)
	// get the chain information
	GetChainInfo(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ChainInfoResponse, error)
	// get transaction by hash
	GetTxByHash(ctx context.Context, in *TxHashRequest, opts ...grpc.CallOption) (*TransactionResponse, error)
	// get transaction receipt by transaction hash
	GetTxReceiptByTxHash(ctx context.Context, in *TxHashRequest, opts ...grpc.CallOption) (*TxReceipt, error)
	// get block by hash
	GetBlockByHash(ctx context.Context, in *GetBlockByHashRequest, opts ...grpc.CallOption) (*BlockResponse, error)
	// get block by number
	GetBlockByNumber(ctx context.Context, in *GetBlockByNumberRequest, opts ...grpc.CallOption) (*BlockResponse, error)
	// get account
	GetAccount(ctx context.Context, in *GetAccountRequest, opts ...grpc.CallOption) (*Account, error)
	// get token balance
	GetTokenBalance(ctx context.Context, in *GetTokenBalanceRequest, opts ...grpc.CallOption) (*GetTokenBalanceResponse, error)
	// get contract
	GetContract(ctx context.Context, in *GetContractRequest, opts ...grpc.CallOption) (*Contract, error)
	// get contract storage
	GetContractStorage(ctx context.Context, in *GetContractStorageRequest, opts ...grpc.CallOption) (*GetContractStorageResponse, error)
	// send transaction
	SendTransaction(ctx context.Context, in *TransactionRequest, opts ...grpc.CallOption) (*SendTransactionResponse, error)
	// execute transaction
	ExecTransaction(ctx context.Context, in *TransactionRequest, opts ...grpc.CallOption) (*TxReceipt, error)
}

type apiServiceClient struct {
	cc *grpc.ClientConn
}

func NewApiServiceClient(cc *grpc.ClientConn) ApiServiceClient {
	return &apiServiceClient{cc}
}

func (c *apiServiceClient) GetNodeInfo(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*NodeInfoResponse, error) {
	out := new(NodeInfoResponse)
	err := c.cc.Invoke(ctx, "/rpcpb.ApiService/GetNodeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) GetChainInfo(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ChainInfoResponse, error) {
	out := new(ChainInfoResponse)
	err := c.cc.Invoke(ctx, "/rpcpb.ApiService/GetChainInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) GetTxByHash(ctx context.Context, in *TxHashRequest, opts ...grpc.CallOption) (*TransactionResponse, error) {
	out := new(TransactionResponse)
	err := c.cc.Invoke(ctx, "/rpcpb.ApiService/GetTxByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) GetTxReceiptByTxHash(ctx context.Context, in *TxHashRequest, opts ...grpc.CallOption) (*TxReceipt, error) {
	out := new(TxReceipt)
	err := c.cc.Invoke(ctx, "/rpcpb.ApiService/GetTxReceiptByTxHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) GetBlockByHash(ctx context.Context, in *GetBlockByHashRequest, opts ...grpc.CallOption) (*BlockResponse, error) {
	out := new(BlockResponse)
	err := c.cc.Invoke(ctx, "/rpcpb.ApiService/GetBlockByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) GetBlockByNumber(ctx context.Context, in *GetBlockByNumberRequest, opts ...grpc.CallOption) (*BlockResponse, error) {
	out := new(BlockResponse)
	err := c.cc.Invoke(ctx, "/rpcpb.ApiService/GetBlockByNumber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) GetAccount(ctx context.Context, in *GetAccountRequest, opts ...grpc.CallOption) (*Account, error) {
	out := new(Account)
	err := c.cc.Invoke(ctx, "/rpcpb.ApiService/GetAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) GetTokenBalance(ctx context.Context, in *GetTokenBalanceRequest, opts ...grpc.CallOption) (*GetTokenBalanceResponse, error) {
	out := new(GetTokenBalanceResponse)
	err := c.cc.Invoke(ctx, "/rpcpb.ApiService/GetTokenBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) GetContract(ctx context.Context, in *GetContractRequest, opts ...grpc.CallOption) (*Contract, error) {
	out := new(Contract)
	err := c.cc.Invoke(ctx, "/rpcpb.ApiService/GetContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) GetContractStorage(ctx context.Context, in *GetContractStorageRequest, opts ...grpc.CallOption) (*GetContractStorageResponse, error) {
	out := new(GetContractStorageResponse)
	err := c.cc.Invoke(ctx, "/rpcpb.ApiService/GetContractStorage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) SendTransaction(ctx context.Context, in *TransactionRequest, opts ...grpc.CallOption) (*SendTransactionResponse, error) {
	out := new(SendTransactionResponse)
	err := c.cc.Invoke(ctx, "/rpcpb.ApiService/SendTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) ExecTransaction(ctx context.Context, in *TransactionRequest, opts ...grpc.CallOption) (*TxReceipt, error) {
	out := new(TxReceipt)
	err := c.cc.Invoke(ctx, "/rpcpb.ApiService/ExecTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiServiceServer is the server API for ApiService service.
type ApiServiceServer interface {
	// get the node information
	GetNodeInfo(context.Context, *EmptyRequest) (*NodeInfoResponse, error)
	// get the chain information
	GetChainInfo(context.Context, *EmptyRequest) (*ChainInfoResponse, error)
	// get transaction by hash
	GetTxByHash(context.Context, *TxHashRequest) (*TransactionResponse, error)
	// get transaction receipt by transaction hash
	GetTxReceiptByTxHash(context.Context, *TxHashRequest) (*TxReceipt, error)
	// get block by hash
	GetBlockByHash(context.Context, *GetBlockByHashRequest) (*BlockResponse, error)
	// get block by number
	GetBlockByNumber(context.Context, *GetBlockByNumberRequest) (*BlockResponse, error)
	// get account
	GetAccount(context.Context, *GetAccountRequest) (*Account, error)
	// get token balance
	GetTokenBalance(context.Context, *GetTokenBalanceRequest) (*GetTokenBalanceResponse, error)
	// get contract
	GetContract(context.Context, *GetContractRequest) (*Contract, error)
	// get contract storage
	GetContractStorage(context.Context, *GetContractStorageRequest) (*GetContractStorageResponse, error)
	// send transaction
	SendTransaction(context.Context, *TransactionRequest) (*SendTransactionResponse, error)
	// execute transaction
	ExecTransaction(context.Context, *TransactionRequest) (*TxReceipt, error)
}

func RegisterApiServiceServer(s *grpc.Server, srv ApiServiceServer) {
	s.RegisterService(&_ApiService_serviceDesc, srv)
}

func _ApiService_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.ApiService/GetNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).GetNodeInfo(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_GetChainInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).GetChainInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.ApiService/GetChainInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).GetChainInfo(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_GetTxByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).GetTxByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.ApiService/GetTxByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).GetTxByHash(ctx, req.(*TxHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_GetTxReceiptByTxHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).GetTxReceiptByTxHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.ApiService/GetTxReceiptByTxHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).GetTxReceiptByTxHash(ctx, req.(*TxHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_GetBlockByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).GetBlockByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.ApiService/GetBlockByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).GetBlockByHash(ctx, req.(*GetBlockByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_GetBlockByNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockByNumberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).GetBlockByNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.ApiService/GetBlockByNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).GetBlockByNumber(ctx, req.(*GetBlockByNumberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_GetAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).GetAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.ApiService/GetAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).GetAccount(ctx, req.(*GetAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_GetTokenBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).GetTokenBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.ApiService/GetTokenBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).GetTokenBalance(ctx, req.(*GetTokenBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_GetContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).GetContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.ApiService/GetContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).GetContract(ctx, req.(*GetContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_GetContractStorage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetContractStorageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).GetContractStorage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.ApiService/GetContractStorage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).GetContractStorage(ctx, req.(*GetContractStorageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_SendTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).SendTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.ApiService/SendTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).SendTransaction(ctx, req.(*TransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_ExecTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).ExecTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcpb.ApiService/ExecTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).ExecTransaction(ctx, req.(*TransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ApiService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpcpb.ApiService",
	HandlerType: (*ApiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNodeInfo",
			Handler:    _ApiService_GetNodeInfo_Handler,
		},
		{
			MethodName: "GetChainInfo",
			Handler:    _ApiService_GetChainInfo_Handler,
		},
		{
			MethodName: "GetTxByHash",
			Handler:    _ApiService_GetTxByHash_Handler,
		},
		{
			MethodName: "GetTxReceiptByTxHash",
			Handler:    _ApiService_GetTxReceiptByTxHash_Handler,
		},
		{
			MethodName: "GetBlockByHash",
			Handler:    _ApiService_GetBlockByHash_Handler,
		},
		{
			MethodName: "GetBlockByNumber",
			Handler:    _ApiService_GetBlockByNumber_Handler,
		},
		{
			MethodName: "GetAccount",
			Handler:    _ApiService_GetAccount_Handler,
		},
		{
			MethodName: "GetTokenBalance",
			Handler:    _ApiService_GetTokenBalance_Handler,
		},
		{
			MethodName: "GetContract",
			Handler:    _ApiService_GetContract_Handler,
		},
		{
			MethodName: "GetContractStorage",
			Handler:    _ApiService_GetContractStorage_Handler,
		},
		{
			MethodName: "SendTransaction",
			Handler:    _ApiService_SendTransaction_Handler,
		},
		{
			MethodName: "ExecTransaction",
			Handler:    _ApiService_ExecTransaction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/pb/rpc.proto",
}

func (m *EmptyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmptyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PeerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Addr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NetworkInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.PeerCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.PeerCount))
	}
	if len(m.PeerInfo) > 0 {
		for _, msg := range m.PeerInfo {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NodeInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BuildTime) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.BuildTime)))
		i += copy(dAtA[i:], m.BuildTime)
	}
	if len(m.GitHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.GitHash)))
		i += copy(dAtA[i:], m.GitHash)
	}
	if len(m.Mode) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Mode)))
		i += copy(dAtA[i:], m.Mode)
	}
	if m.Network != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Network.Size()))
		n1, err := m.Network.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AmountLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AmountLimit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.Value != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Contract) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Contract)))
		i += copy(dAtA[i:], m.Contract)
	}
	if len(m.ActionName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.ActionName)))
		i += copy(dAtA[i:], m.ActionName)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxReceipt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxReceipt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TxHash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.TxHash)))
		i += copy(dAtA[i:], m.TxHash)
	}
	if m.GasUsage != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GasUsage))))
		i += 8
	}
	if len(m.RamUsage) > 0 {
		for k, _ := range m.RamUsage {
			dAtA[i] = 0x1a
			i++
			v := m.RamUsage[k]
			mapSize := 1 + len(k) + sovRpc(uint64(len(k))) + 1 + sovRpc(uint64(v))
			i = encodeVarintRpc(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpc(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintRpc(dAtA, i, uint64(v))
		}
	}
	if m.StatusCode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.StatusCode))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Returns) > 0 {
		for _, s := range m.Returns {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Receipts) > 0 {
		for _, msg := range m.Receipts {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxReceipt_Receipt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxReceipt_Receipt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FuncName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.FuncName)))
		i += copy(dAtA[i:], m.FuncName)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Time))
	}
	if m.Expiration != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Expiration))
	}
	if m.GasRatio != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GasRatio))))
		i += 8
	}
	if m.GasLimit != 0 {
		dAtA[i] = 0x29
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GasLimit))))
		i += 8
	}
	if m.Delay != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Delay))
	}
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Signers) > 0 {
		for _, s := range m.Signers {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Publisher) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Publisher)))
		i += copy(dAtA[i:], m.Publisher)
	}
	if len(m.ReferredTx) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.ReferredTx)))
		i += copy(dAtA[i:], m.ReferredTx)
	}
	if len(m.AmountLimit) > 0 {
		for _, msg := range m.AmountLimit {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TxReceipt != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.TxReceipt.Size()))
		n2, err := m.TxReceipt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Status))
	}
	if m.Transaction != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Transaction.Size()))
		n3, err := m.Transaction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Signature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signature) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Algorithm != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Algorithm))
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Time))
	}
	if m.Expiration != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Expiration))
	}
	if m.GasRatio != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GasRatio))))
		i += 8
	}
	if m.GasLimit != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GasLimit))))
		i += 8
	}
	if m.Delay != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Delay))
	}
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			dAtA[i] = 0x32
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AmountLimit) > 0 {
		for _, msg := range m.AmountLimit {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Signers) > 0 {
		for _, s := range m.Signers {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Signatures) > 0 {
		for _, msg := range m.Signatures {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Publisher) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Publisher)))
		i += copy(dAtA[i:], m.Publisher)
	}
	if len(m.PublisherSigs) > 0 {
		for _, msg := range m.PublisherSigs {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Version))
	}
	if len(m.ParentHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.ParentHash)))
		i += copy(dAtA[i:], m.ParentHash)
	}
	if len(m.TxMerkleHash) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.TxMerkleHash)))
		i += copy(dAtA[i:], m.TxMerkleHash)
	}
	if len(m.TxReceiptMerkleHash) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.TxReceiptMerkleHash)))
		i += copy(dAtA[i:], m.TxReceiptMerkleHash)
	}
	if m.Number != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Number))
	}
	if len(m.Witness) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Witness)))
		i += copy(dAtA[i:], m.Witness)
	}
	if m.Time != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Time))
	}
	if m.GasUsage != 0 {
		dAtA[i] = 0x49
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GasUsage))))
		i += 8
	}
	if m.TxCount != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.TxCount))
	}
	if m.Info != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Info.Size()))
		n4, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Transactions) > 0 {
		for _, msg := range m.Transactions {
			dAtA[i] = 0x62
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Block_Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block_Info) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Mode))
	}
	if m.Thread != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Thread))
	}
	if len(m.BatchIndex) > 0 {
		dAtA6 := make([]byte, len(m.BatchIndex)*10)
		var j5 int
		for _, num1 := range m.BatchIndex {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Status))
	}
	if m.Block != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Block.Size()))
		n7, err := m.Block.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChainInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NetName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.NetName)))
		i += copy(dAtA[i:], m.NetName)
	}
	if len(m.ProtocolVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.ProtocolVersion)))
		i += copy(dAtA[i:], m.ProtocolVersion)
	}
	if m.HeadBlock != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.HeadBlock))
	}
	if len(m.HeadBlockHash) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.HeadBlockHash)))
		i += copy(dAtA[i:], m.HeadBlockHash)
	}
	if m.LibBlock != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.LibBlock))
	}
	if len(m.LibBlockHash) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.LibBlockHash)))
		i += copy(dAtA[i:], m.LibBlockHash)
	}
	if len(m.WitnessList) > 0 {
		for _, s := range m.WitnessList {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxHashRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetBlockByHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlockByHashRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.Complete {
		dAtA[i] = 0x10
		i++
		if m.Complete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetBlockByNumberRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlockByNumberRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Number))
	}
	if m.Complete {
		dAtA[i] = 0x10
		i++
		if m.Complete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FrozenBalance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FrozenBalance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amount))))
		i += 8
	}
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Time))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Account) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Balance != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Balance))))
		i += 8
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.CreateTime))
	}
	if m.GasInfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.GasInfo.Size()))
		n8, err := m.GasInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.RamInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.RamInfo.Size()))
		n9, err := m.RamInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Permissions) > 0 {
		for k, _ := range m.Permissions {
			dAtA[i] = 0x32
			i++
			v := m.Permissions[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovRpc(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovRpc(uint64(len(k))) + msgSize
			i = encodeVarintRpc(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpc(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintRpc(dAtA, i, uint64(v.Size()))
				n10, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n10
			}
		}
	}
	if len(m.Groups) > 0 {
		for k, _ := range m.Groups {
			dAtA[i] = 0x3a
			i++
			v := m.Groups[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovRpc(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovRpc(uint64(len(k))) + msgSize
			i = encodeVarintRpc(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpc(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintRpc(dAtA, i, uint64(v.Size()))
				n11, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n11
			}
		}
	}
	if len(m.FrozenBalances) > 0 {
		for _, msg := range m.FrozenBalances {
			dAtA[i] = 0x42
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Account_PledgeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account_PledgeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pledger) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Pledger)))
		i += copy(dAtA[i:], m.Pledger)
	}
	if m.Amount != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amount))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Account_GasInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account_GasInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurrentTotal != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CurrentTotal))))
		i += 8
	}
	if m.TransferableGas != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TransferableGas))))
		i += 8
	}
	if m.PledgeGas != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PledgeGas))))
		i += 8
	}
	if m.IncreaseSpeed != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.IncreaseSpeed))))
		i += 8
	}
	if m.Limit != 0 {
		dAtA[i] = 0x29
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Limit))))
		i += 8
	}
	if len(m.PledgedInfo) > 0 {
		for _, msg := range m.PledgedInfo {
			dAtA[i] = 0x32
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Account_RAMInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account_RAMInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Available != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Available))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Account_Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account_Item) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.IsKeyPair {
		dAtA[i] = 0x10
		i++
		if m.IsKeyPair {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Weight != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Weight))
	}
	if len(m.Permission) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Permission)))
		i += copy(dAtA[i:], m.Permission)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Account_Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account_Group) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Account_Permission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account_Permission) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Groups) > 0 {
		for _, s := range m.Groups {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Threshold != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Threshold))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAccountRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAccountRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.ByLongestChain {
		dAtA[i] = 0x10
		i++
		if m.ByLongestChain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Contract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contract) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Abis) > 0 {
		for _, msg := range m.Abis {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Contract_ABI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contract_ABI) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AmountLimit) > 0 {
		for _, msg := range m.AmountLimit {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetContractRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetContractRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.ByLongestChain {
		dAtA[i] = 0x10
		i++
		if m.ByLongestChain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetContractStorageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetContractStorageRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Field) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Field)))
		i += copy(dAtA[i:], m.Field)
	}
	if m.ByLongestChain {
		dAtA[i] = 0x20
		i++
		if m.ByLongestChain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetContractStorageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetContractStorageResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SendTransactionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendTransactionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetTokenBalanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTokenBalanceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Balance != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Balance))))
		i += 8
	}
	if len(m.FrozenBalances) > 0 {
		for _, msg := range m.FrozenBalances {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetTokenBalanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTokenBalanceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Account) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Account)))
		i += copy(dAtA[i:], m.Account)
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.ByLongestChain {
		dAtA[i] = 0x18
		i++
		if m.ByLongestChain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintRpc(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EmptyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PeerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.PeerCount != 0 {
		n += 1 + sovRpc(uint64(m.PeerCount))
	}
	if len(m.PeerInfo) > 0 {
		for _, e := range m.PeerInfo {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BuildTime)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.GitHash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Network != nil {
		l = m.Network.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AmountLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Value != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Action) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Contract)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.ActionName)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxReceipt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.GasUsage != 0 {
		n += 9
	}
	if len(m.RamUsage) > 0 {
		for k, v := range m.RamUsage {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovRpc(uint64(len(k))) + 1 + sovRpc(uint64(v))
			n += mapEntrySize + 1 + sovRpc(uint64(mapEntrySize))
		}
	}
	if m.StatusCode != 0 {
		n += 1 + sovRpc(uint64(m.StatusCode))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.Returns) > 0 {
		for _, s := range m.Returns {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.Receipts) > 0 {
		for _, e := range m.Receipts {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxReceipt_Receipt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FuncName)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Transaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovRpc(uint64(m.Time))
	}
	if m.Expiration != 0 {
		n += 1 + sovRpc(uint64(m.Expiration))
	}
	if m.GasRatio != 0 {
		n += 9
	}
	if m.GasLimit != 0 {
		n += 9
	}
	if m.Delay != 0 {
		n += 1 + sovRpc(uint64(m.Delay))
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.Signers) > 0 {
		for _, s := range m.Signers {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	l = len(m.Publisher)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.ReferredTx)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.AmountLimit) > 0 {
		for _, e := range m.AmountLimit {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.TxReceipt != nil {
		l = m.TxReceipt.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRpc(uint64(m.Status))
	}
	if m.Transaction != nil {
		l = m.Transaction.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Signature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Algorithm != 0 {
		n += 1 + sovRpc(uint64(m.Algorithm))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovRpc(uint64(m.Time))
	}
	if m.Expiration != 0 {
		n += 1 + sovRpc(uint64(m.Expiration))
	}
	if m.GasRatio != 0 {
		n += 9
	}
	if m.GasLimit != 0 {
		n += 9
	}
	if m.Delay != 0 {
		n += 1 + sovRpc(uint64(m.Delay))
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.AmountLimit) > 0 {
		for _, e := range m.AmountLimit {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.Signers) > 0 {
		for _, s := range m.Signers {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	l = len(m.Publisher)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.PublisherSigs) > 0 {
		for _, e := range m.PublisherSigs {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovRpc(uint64(m.Version))
	}
	l = len(m.ParentHash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.TxMerkleHash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.TxReceiptMerkleHash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovRpc(uint64(m.Number))
	}
	l = len(m.Witness)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovRpc(uint64(m.Time))
	}
	if m.GasUsage != 0 {
		n += 9
	}
	if m.TxCount != 0 {
		n += 1 + sovRpc(uint64(m.TxCount))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Block_Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovRpc(uint64(m.Mode))
	}
	if m.Thread != 0 {
		n += 1 + sovRpc(uint64(m.Thread))
	}
	if len(m.BatchIndex) > 0 {
		l = 0
		for _, e := range m.BatchIndex {
			l += sovRpc(uint64(e))
		}
		n += 1 + sovRpc(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRpc(uint64(m.Status))
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChainInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NetName)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.ProtocolVersion)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.HeadBlock != 0 {
		n += 1 + sovRpc(uint64(m.HeadBlock))
	}
	l = len(m.HeadBlockHash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.LibBlock != 0 {
		n += 1 + sovRpc(uint64(m.LibBlock))
	}
	l = len(m.LibBlockHash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.WitnessList) > 0 {
		for _, s := range m.WitnessList {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlockByHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Complete {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlockByNumberRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovRpc(uint64(m.Number))
	}
	if m.Complete {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FrozenBalance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amount != 0 {
		n += 9
	}
	if m.Time != 0 {
		n += 1 + sovRpc(uint64(m.Time))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Account) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Balance != 0 {
		n += 9
	}
	if m.CreateTime != 0 {
		n += 1 + sovRpc(uint64(m.CreateTime))
	}
	if m.GasInfo != nil {
		l = m.GasInfo.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.RamInfo != nil {
		l = m.RamInfo.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.Permissions) > 0 {
		for k, v := range m.Permissions {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRpc(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRpc(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRpc(uint64(mapEntrySize))
		}
	}
	if len(m.Groups) > 0 {
		for k, v := range m.Groups {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRpc(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRpc(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRpc(uint64(mapEntrySize))
		}
	}
	if len(m.FrozenBalances) > 0 {
		for _, e := range m.FrozenBalances {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Account_PledgeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pledger)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Amount != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Account_GasInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrentTotal != 0 {
		n += 9
	}
	if m.TransferableGas != 0 {
		n += 9
	}
	if m.PledgeGas != 0 {
		n += 9
	}
	if m.IncreaseSpeed != 0 {
		n += 9
	}
	if m.Limit != 0 {
		n += 9
	}
	if len(m.PledgedInfo) > 0 {
		for _, e := range m.PledgedInfo {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Account_RAMInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Available != 0 {
		n += 1 + sovRpc(uint64(m.Available))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Account_Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.IsKeyPair {
		n += 2
	}
	if m.Weight != 0 {
		n += 1 + sovRpc(uint64(m.Weight))
	}
	l = len(m.Permission)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Account_Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Account_Permission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.Groups) > 0 {
		for _, s := range m.Groups {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.Threshold != 0 {
		n += 1 + sovRpc(uint64(m.Threshold))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAccountRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.ByLongestChain {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Contract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.Abis) > 0 {
		for _, e := range m.Abis {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Contract_ABI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.AmountLimit) > 0 {
		for _, e := range m.AmountLimit {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetContractRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.ByLongestChain {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetContractStorageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.ByLongestChain {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetContractStorageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SendTransactionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTokenBalanceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Balance != 0 {
		n += 9
	}
	if len(m.FrozenBalances) > 0 {
		for _, e := range m.FrozenBalances {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTokenBalanceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.ByLongestChain {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRpc(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRpc(x uint64) (n int) {
	return sovRpc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EmptyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerCount", wireType)
			}
			m.PeerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerInfo = append(m.PeerInfo, &PeerInfo{})
			if err := m.PeerInfo[len(m.PeerInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &NetworkInfo{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AmountLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AmountLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AmountLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxReceipt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxReceipt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxReceipt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GasUsage = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RamUsage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RamUsage == nil {
				m.RamUsage = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRpc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRpc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRpc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RamUsage[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= (TxReceipt_StatusCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Returns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Returns = append(m.Returns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receipts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receipts = append(m.Receipts, &TxReceipt_Receipt{})
			if err := m.Receipts[len(m.Receipts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxReceipt_Receipt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Receipt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Receipt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FuncName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			m.Expiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasRatio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GasRatio = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GasLimit = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delay", wireType)
			}
			m.Delay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delay |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publisher", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Publisher = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferredTx", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferredTx = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountLimit = append(m.AmountLimit, &AmountLimit{})
			if err := m.AmountLimit[len(m.AmountLimit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxReceipt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxReceipt == nil {
				m.TxReceipt = &TxReceipt{}
			}
			if err := m.TxReceipt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (TransactionResponse_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transaction == nil {
				m.Transaction = &Transaction{}
			}
			if err := m.Transaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= (Signature_Algorithm(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			m.Expiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expiration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasRatio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GasRatio = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GasLimit = float64(math.Float64frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delay", wireType)
			}
			m.Delay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delay |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountLimit = append(m.AmountLimit, &AmountLimit{})
			if err := m.AmountLimit[len(m.AmountLimit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, &Signature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publisher", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Publisher = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublisherSigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublisherSigs = append(m.PublisherSigs, &Signature{})
			if err := m.PublisherSigs[len(m.PublisherSigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxMerkleHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxMerkleHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxReceiptMerkleHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxReceiptMerkleHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Witness", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Witness = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GasUsage = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxCount", wireType)
			}
			m.TxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &Block_Info{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &Transaction{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block_Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thread", wireType)
			}
			m.Thread = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Thread |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BatchIndex = append(m.BatchIndex, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpc
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BatchIndex) == 0 {
					m.BatchIndex = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BatchIndex = append(m.BatchIndex, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchIndex", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (BlockResponse_Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadBlock", wireType)
			}
			m.HeadBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeadBlock |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadBlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadBlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LibBlock", wireType)
			}
			m.LibBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LibBlock |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LibBlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LibBlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WitnessList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WitnessList = append(m.WitnessList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlockByHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlockByHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlockByHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Complete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Complete = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlockByNumberRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlockByNumberRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlockByNumberRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Complete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Complete = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FrozenBalance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FrozenBalance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FrozenBalance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amount = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Balance = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GasInfo == nil {
				m.GasInfo = &Account_GasInfo{}
			}
			if err := m.GasInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RamInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RamInfo == nil {
				m.RamInfo = &Account_RAMInfo{}
			}
			if err := m.RamInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = make(map[string]*Account_Permission)
			}
			var mapkey string
			var mapvalue *Account_Permission
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRpc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRpc
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthRpc
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Account_Permission{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRpc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRpc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Permissions[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Groups == nil {
				m.Groups = make(map[string]*Account_Group)
			}
			var mapkey string
			var mapvalue *Account_Group
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRpc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRpc
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthRpc
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Account_Group{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRpc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRpc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Groups[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FrozenBalances = append(m.FrozenBalances, &FrozenBalance{})
			if err := m.FrozenBalances[len(m.FrozenBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account_PledgeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PledgeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PledgeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pledger", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pledger = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amount = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account_GasInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GasInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GasInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTotal", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CurrentTotal = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferableGas", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TransferableGas = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PledgeGas", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PledgeGas = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncreaseSpeed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.IncreaseSpeed = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Limit = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PledgedInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PledgedInfo = append(m.PledgedInfo, &Account_PledgeInfo{})
			if err := m.PledgedInfo[len(m.PledgedInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account_RAMInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RAMInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RAMInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			m.Available = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Available |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account_Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsKeyPair", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsKeyPair = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account_Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Account_Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account_Permission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Permission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Permission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Account_Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccountRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccountRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByLongestChain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ByLongestChain = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Abis = append(m.Abis, &Contract_ABI{})
			if err := m.Abis[len(m.Abis)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contract_ABI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ABI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ABI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountLimit = append(m.AmountLimit, &AmountLimit{})
			if err := m.AmountLimit[len(m.AmountLimit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetContractRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetContractRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetContractRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByLongestChain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ByLongestChain = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetContractStorageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetContractStorageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetContractStorageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByLongestChain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ByLongestChain = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetContractStorageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetContractStorageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetContractStorageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendTransactionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendTransactionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendTransactionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTokenBalanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTokenBalanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTokenBalanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Balance = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenBalances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FrozenBalances = append(m.FrozenBalances, &FrozenBalance{})
			if err := m.FrozenBalances[len(m.FrozenBalances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTokenBalanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTokenBalanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTokenBalanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByLongestChain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ByLongestChain = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRpc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRpc
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRpc
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRpc(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRpc = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRpc   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("rpc/pb/rpc.proto", fileDescriptor_rpc_5d6ef4678745fb9b) }

var fileDescriptor_rpc_5d6ef4678745fb9b = []byte{
	// 2630 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x18, 0x5d, 0x6f, 0x1b, 0xc7,
	0xd1, 0x47, 0x8a, 0x1f, 0x37, 0xa4, 0xc8, 0xf3, 0x4a, 0x91, 0xa9, 0xb3, 0xa3, 0xd8, 0x97, 0xa4,
	0x76, 0x82, 0x44, 0x4c, 0xe4, 0x38, 0xdf, 0x29, 0x4a, 0xc9, 0x8c, 0x22, 0xd8, 0xa6, 0x94, 0x23,
	0x95, 0x34, 0x40, 0x81, 0xeb, 0x91, 0x5c, 0x51, 0x57, 0x91, 0x77, 0xec, 0xdd, 0xd2, 0xa6, 0x2a,
	0xe8, 0xa1, 0x7d, 0xe8, 0x63, 0x83, 0xa2, 0x2f, 0x05, 0xfa, 0x43, 0x5a, 0x20, 0x7f, 0xa0, 0x8f,
	0x05, 0xfa, 0x03, 0x5a, 0x24, 0xfd, 0x07, 0xf9, 0x03, 0xc5, 0xce, 0xee, 0x7d, 0x91, 0x27, 0xc7,
	0x4f, 0x77, 0x33, 0x3b, 0x3b, 0x33, 0x3b, 0xdf, 0xbb, 0xa0, 0xf9, 0xd3, 0x41, 0x73, 0xda, 0x6f,
	0xfa, 0xd3, 0xc1, 0xf6, 0xd4, 0xf7, 0x98, 0x47, 0x0a, 0xfe, 0x74, 0x30, 0xed, 0xeb, 0xb7, 0x46,
	0x9e, 0x37, 0x1a, 0xd3, 0xa6, 0x3d, 0x75, 0x9a, 0xb6, 0xeb, 0x7a, 0xcc, 0x66, 0x8e, 0xe7, 0x06,
	0x82, 0xc8, 0xa8, 0x41, 0xb5, 0x3d, 0x99, 0xb2, 0x73, 0x93, 0xfe, 0x76, 0x46, 0x03, 0x66, 0x6c,
	0x43, 0xf9, 0x88, 0x52, 0xff, 0xc0, 0x3d, 0xf1, 0x48, 0x0d, 0x72, 0xce, 0xb0, 0xa1, 0xdc, 0x56,
	0xee, 0xa9, 0x66, 0xce, 0x19, 0x12, 0x02, 0x2b, 0xf6, 0x70, 0xe8, 0x37, 0x72, 0x88, 0xc1, 0x7f,
	0xe3, 0x37, 0x50, 0xe9, 0x50, 0xf6, 0xcc, 0xf3, 0xcf, 0x32, 0xb7, 0xbc, 0x0c, 0x30, 0xa5, 0xd4,
	0xb7, 0x06, 0xde, 0xcc, 0x65, 0xb8, 0xb1, 0x60, 0xaa, 0x1c, 0xb3, 0xc7, 0x11, 0xe4, 0x2d, 0x40,
	0xc0, 0x72, 0xdc, 0x13, 0xaf, 0x91, 0xbf, 0x9d, 0xbf, 0x57, 0xd9, 0xa9, 0x6f, 0xa3, 0xda, 0xdb,
	0xa1, 0x16, 0x66, 0x79, 0x2a, 0xff, 0x8c, 0x3f, 0x29, 0xa0, 0x75, 0xbc, 0x21, 0x45, 0x34, 0x0d,
	0xa6, 0x9e, 0x1b, 0x50, 0x2e, 0xa1, 0x3f, 0x73, 0xc6, 0x43, 0x8b, 0x39, 0x13, 0x2a, 0x25, 0xab,
	0x88, 0xe9, 0x39, 0x13, 0x4a, 0x36, 0xa1, 0x3c, 0x72, 0x98, 0x75, 0x6a, 0x07, 0xa7, 0x52, 0xef,
	0xd2, 0xc8, 0x61, 0x5f, 0xd8, 0xc1, 0x29, 0x3f, 0xce, 0xc4, 0x1b, 0xd2, 0x46, 0x5e, 0x1c, 0x87,
	0xff, 0x93, 0xb7, 0xa0, 0xe4, 0x8a, 0xe3, 0x34, 0x56, 0x6e, 0x2b, 0xf7, 0x2a, 0x3b, 0x44, 0xaa,
	0x93, 0x38, 0xa4, 0x19, 0x92, 0x18, 0x1f, 0x41, 0xa5, 0x35, 0xe1, 0x07, 0x79, 0xec, 0x4c, 0x1c,
	0x46, 0xd6, 0xa1, 0xc0, 0xbc, 0x33, 0xea, 0x4a, 0x2d, 0x04, 0xc0, 0xb1, 0x4f, 0xed, 0xf1, 0x8c,
	0xa2, 0x78, 0xc5, 0x14, 0x80, 0xf1, 0x0d, 0x14, 0x5b, 0x03, 0xee, 0x08, 0xa2, 0x43, 0x79, 0xe0,
	0xb9, 0xcc, 0xb7, 0x07, 0x4c, 0x6e, 0x8c, 0x60, 0xf2, 0x0a, 0x54, 0x6c, 0xa4, 0xb2, 0x5c, 0x7b,
	0x42, 0xe5, 0x01, 0x40, 0xa0, 0x3a, 0xf6, 0x84, 0xf2, 0x33, 0x0c, 0x6d, 0x66, 0x87, 0x67, 0xe0,
	0xff, 0xc6, 0x7f, 0x56, 0x40, 0xed, 0xcd, 0x4d, 0x3a, 0xa0, 0xce, 0x94, 0x91, 0x1b, 0x50, 0x62,
	0x73, 0x71, 0x7e, 0xc1, 0xbd, 0xc8, 0xe6, 0x78, 0xfc, 0x9b, 0xa0, 0x8e, 0xec, 0xc0, 0x9a, 0x05,
	0xf6, 0x28, 0xd4, 0xad, 0x3c, 0xb2, 0x83, 0x63, 0x0e, 0x93, 0x4f, 0x40, 0xf5, 0xed, 0x89, 0x5c,
	0x14, 0x8e, 0xd9, 0x92, 0x96, 0x88, 0x58, 0x6f, 0x9b, 0xf6, 0x04, 0xa9, 0xdb, 0x2e, 0xf3, 0xcf,
	0xcd, 0xb2, 0x2f, 0x41, 0xf2, 0x29, 0x54, 0x02, 0x66, 0xb3, 0x59, 0x60, 0x0d, 0xb8, 0x7d, 0xb9,
	0x21, 0x6b, 0x3b, 0x37, 0x97, 0xb6, 0x77, 0x91, 0x66, 0xcf, 0x1b, 0x52, 0x13, 0x82, 0xe8, 0x9f,
	0x34, 0xa0, 0x34, 0xa1, 0x01, 0x0a, 0x2e, 0x08, 0x87, 0x49, 0x90, 0xaf, 0xf8, 0x94, 0xcd, 0x7c,
	0x37, 0x68, 0x14, 0x6f, 0xe7, 0xf9, 0x8a, 0x04, 0xc9, 0x7b, 0x50, 0xf6, 0x05, 0xd7, 0xa0, 0x51,
	0x42, 0x6d, 0x1b, 0xcb, 0xda, 0x8a, 0xaf, 0x19, 0x51, 0xea, 0x9f, 0xc0, 0x6a, 0xea, 0x08, 0x44,
	0x83, 0xfc, 0x19, 0x3d, 0x97, 0x76, 0xe2, 0xbf, 0x69, 0xe7, 0xe5, 0xa5, 0xf3, 0x3e, 0xce, 0x7d,
	0xa8, 0xe8, 0xbf, 0x80, 0x52, 0x68, 0xe2, 0x9b, 0xa0, 0x9e, 0xcc, 0xdc, 0x81, 0xf0, 0x91, 0x74,
	0x21, 0x47, 0xa0, 0x87, 0x1a, 0x50, 0xe2, 0xee, 0xa4, 0x32, 0xfc, 0x55, 0x33, 0x04, 0x8d, 0xbf,
	0x2b, 0x00, 0xb1, 0x0d, 0x48, 0x05, 0x4a, 0xdd, 0xe3, 0xbd, 0xbd, 0x76, 0xb7, 0xab, 0x5d, 0x23,
	0x75, 0xa8, 0xec, 0xb7, 0xba, 0x96, 0x79, 0xdc, 0xb1, 0x0e, 0x8f, 0x7b, 0x9a, 0x42, 0x36, 0x80,
	0xec, 0xb6, 0x1e, 0xb7, 0x3a, 0x7b, 0x6d, 0xab, 0x73, 0xd8, 0xb3, 0xda, 0x9d, 0xc3, 0xe3, 0xfd,
	0x2f, 0xb4, 0x1c, 0x59, 0x83, 0xfa, 0xd7, 0xe6, 0x61, 0x67, 0xdf, 0x3a, 0x6a, 0x99, 0xad, 0x27,
	0xed, 0x5e, 0xdb, 0xd4, 0xf2, 0xe4, 0x3a, 0xac, 0x9a, 0xc7, 0x9d, 0xde, 0xc1, 0x93, 0xb6, 0xd5,
	0x36, 0xcd, 0x43, 0x53, 0x5b, 0xe1, 0xdc, 0x39, 0xcc, 0x99, 0x15, 0xe2, 0x4d, 0xbd, 0x5f, 0x5a,
	0x9f, 0x1f, 0x9a, 0x4f, 0x5a, 0x3d, 0xad, 0xc8, 0x25, 0x3c, 0x3c, 0x3e, 0x7a, 0x7c, 0xb0, 0xd7,
	0xea, 0xb5, 0xad, 0x6e, 0xbb, 0x67, 0xed, 0x1d, 0x3e, 0x6c, 0x6b, 0x25, 0xce, 0xec, 0xb8, 0xf3,
	0xa8, 0x73, 0xf8, 0x75, 0x47, 0x32, 0x2b, 0x1b, 0xdf, 0xe6, 0xa1, 0xd2, 0xf3, 0x6d, 0x37, 0x10,
	0x91, 0xc8, 0xa3, 0x30, 0x11, 0x60, 0xf8, 0xcf, 0x71, 0x98, 0x91, 0xc2, 0x70, 0xf8, 0x4f, 0xb6,
	0x00, 0xe8, 0x7c, 0xea, 0xf8, 0x58, 0x81, 0x30, 0x66, 0xf3, 0x66, 0x02, 0x13, 0x86, 0x24, 0x42,
	0x18, 0x36, 0x22, 0x24, 0x4d, 0x0e, 0x87, 0x8b, 0x63, 0x9e, 0x6a, 0x18, 0x19, 0x62, 0x31, 0x4a,
	0xbd, 0x21, 0x1d, 0xdb, 0xe7, 0x8d, 0xa2, 0xf0, 0x13, 0x02, 0xe4, 0x2e, 0x94, 0x84, 0x86, 0x61,
	0x54, 0xac, 0xca, 0xa8, 0x10, 0xa9, 0x67, 0x86, 0xab, 0xdc, 0x49, 0x81, 0x33, 0x72, 0xa9, 0x1f,
	0x34, 0xca, 0x22, 0xb2, 0x24, 0x48, 0x6e, 0x81, 0x3a, 0x9d, 0xf5, 0xc7, 0x4e, 0x70, 0x4a, 0xfd,
	0x86, 0x2a, 0xaa, 0x4b, 0x84, 0xe0, 0xf9, 0xe9, 0xd3, 0x13, 0xea, 0xfb, 0x74, 0x68, 0xb1, 0x79,
	0x03, 0x44, 0x7e, 0x86, 0xa8, 0xde, 0x9c, 0x3c, 0x80, 0xaa, 0x8d, 0x15, 0x42, 0xea, 0x5d, 0x41,
	0x35, 0xc2, 0xa2, 0x92, 0x28, 0x1e, 0x66, 0xc5, 0x4e, 0x54, 0x92, 0x26, 0x00, 0x9b, 0x5b, 0x32,
	0x50, 0x1b, 0x55, 0xac, 0x44, 0xda, 0x62, 0x44, 0x9b, 0x2a, 0x0b, 0x7f, 0x8d, 0xef, 0x14, 0x58,
	0x4b, 0x78, 0x24, 0xaa, 0x8e, 0x1f, 0x41, 0x51, 0xa4, 0x16, 0xfa, 0xa6, 0xb6, 0x73, 0x27, 0x64,
	0xb2, 0x4c, 0x2b, 0xf3, 0xd1, 0x94, 0x1b, 0xc8, 0x7b, 0x50, 0x61, 0x31, 0x15, 0xfa, 0x31, 0xd6,
	0x3c, 0xb9, 0x3f, 0x49, 0x66, 0xdc, 0x87, 0xa2, 0xe0, 0xc3, 0x23, 0xee, 0xa8, 0xdd, 0x79, 0x78,
	0xd0, 0x79, 0xa8, 0x5d, 0x23, 0x00, 0xc5, 0xa3, 0xd6, 0xde, 0xa3, 0xf6, 0x43, 0x4d, 0x21, 0x1a,
	0x54, 0x0f, 0x4c, 0xb3, 0xfd, 0x55, 0xdb, 0xec, 0x1e, 0xec, 0x3e, 0x6e, 0x6b, 0x39, 0xe3, 0x1f,
	0x0a, 0xa8, 0x5d, 0x67, 0xe4, 0xda, 0x6c, 0xe6, 0x53, 0xf2, 0x21, 0xa8, 0xf6, 0x78, 0xe4, 0xf9,
	0x0e, 0x3b, 0x9d, 0x48, 0xb5, 0x75, 0x29, 0x36, 0x22, 0xda, 0x6e, 0x85, 0x14, 0x66, 0x4c, 0xcc,
	0x9d, 0x15, 0x84, 0x14, 0xa8, 0x70, 0xd5, 0x8c, 0x11, 0xd8, 0x8b, 0xb8, 0xe7, 0x06, 0x16, 0x4f,
	0xf2, 0xbc, 0x58, 0x16, 0x98, 0x47, 0xf4, 0xdc, 0x78, 0x0f, 0xd4, 0x88, 0x29, 0x57, 0x5e, 0x06,
	0xbd, 0x76, 0x8d, 0xac, 0x82, 0xda, 0x6d, 0xef, 0x1d, 0xed, 0x3c, 0x78, 0xff, 0xd1, 0xbb, 0x9a,
	0xc2, 0xd7, 0xda, 0x0f, 0x77, 0x1e, 0x3c, 0x78, 0xf7, 0x23, 0x2d, 0x67, 0xfc, 0x2d, 0x0f, 0x24,
	0x65, 0x4c, 0x6c, 0xa3, 0x51, 0xf4, 0x2b, 0x57, 0x46, 0x7f, 0xee, 0xf9, 0xd1, 0x9f, 0x7f, 0x5e,
	0xf4, 0xaf, 0x5c, 0x15, 0xfd, 0x85, 0x2b, 0xa2, 0xbf, 0xf8, 0xdc, 0xe8, 0x5f, 0x0c, 0xd2, 0xd2,
	0x8b, 0x05, 0xe9, 0xd5, 0x49, 0xf3, 0x0e, 0x40, 0x64, 0xf6, 0xa0, 0xa1, 0x22, 0x3b, 0x6d, 0xd1,
	0x85, 0x66, 0x82, 0x26, 0x9d, 0x66, 0xb0, 0x98, 0x66, 0x1f, 0x40, 0x2d, 0x02, 0xac, 0xc0, 0x19,
	0x05, 0x32, 0x8f, 0x96, 0x79, 0xae, 0x46, 0x74, 0x5d, 0x67, 0x14, 0x18, 0x3f, 0xe4, 0xa1, 0xb0,
	0x3b, 0xf6, 0x06, 0x67, 0x99, 0x25, 0xaa, 0x01, 0xa5, 0xa7, 0xd4, 0x0f, 0x62, 0x6f, 0x84, 0x20,
	0xcf, 0xeb, 0xa9, 0xed, 0x53, 0x57, 0x0e, 0x0e, 0xa2, 0xbb, 0x82, 0x40, 0x61, 0xf3, 0x7c, 0x0d,
	0x6a, 0x6c, 0x6e, 0x4d, 0xa8, 0x7f, 0x36, 0xa6, 0x82, 0x66, 0x05, 0x69, 0xaa, 0x6c, 0xfe, 0x04,
	0x91, 0x48, 0x75, 0x1f, 0x36, 0xe2, 0x34, 0x4e, 0x51, 0x8b, 0xce, 0xb6, 0x16, 0x25, 0x70, 0x62,
	0xd3, 0x06, 0x14, 0xdd, 0xd9, 0xa4, 0x4f, 0x7d, 0x59, 0xcb, 0x24, 0xc4, 0xb5, 0x7d, 0xe6, 0x30,
	0x97, 0x06, 0xbc, 0x98, 0x61, 0x23, 0x91, 0x60, 0x14, 0x6c, 0xe5, 0x44, 0xb0, 0xa5, 0xba, 0xbb,
	0xba, 0xd0, 0xdd, 0x37, 0xa1, 0xcc, 0xe6, 0x72, 0x26, 0x03, 0x71, 0x72, 0x36, 0x17, 0x13, 0xd9,
	0xeb, 0xb0, 0x82, 0xc3, 0x58, 0x05, 0xd3, 0xfd, 0xba, 0x34, 0x30, 0xda, 0x70, 0x1b, 0x87, 0x1f,
	0x5c, 0x26, 0xef, 0x43, 0x35, 0x91, 0xf5, 0x41, 0xa3, 0x9a, 0x0a, 0x99, 0x64, 0x42, 0xa4, 0xe8,
	0xf4, 0x2e, 0xac, 0xe0, 0x9c, 0x18, 0xce, 0x5e, 0x0a, 0x4e, 0x84, 0x62, 0xf6, 0xda, 0x80, 0x22,
	0x3b, 0xf5, 0xa9, 0x3d, 0x94, 0x73, 0xa2, 0x84, 0xb8, 0x33, 0xfa, 0x36, 0x1b, 0x9c, 0x5a, 0x8e,
	0x3b, 0xa4, 0x73, 0x9c, 0x46, 0x0a, 0x26, 0x20, 0xea, 0x80, 0x63, 0x8c, 0x3f, 0x2b, 0xb0, 0x8a,
	0x1a, 0x46, 0x65, 0xef, 0xfe, 0x42, 0xd9, 0xbb, 0x99, 0x3c, 0xc7, 0x55, 0x05, 0xcf, 0x80, 0x42,
	0x9f, 0xaf, 0xcb, 0x52, 0x57, 0x4d, 0xed, 0x11, 0x4b, 0xc6, 0xdd, 0xec, 0xf2, 0xb6, 0x58, 0xd2,
	0x14, 0xe3, 0x8f, 0x39, 0xb8, 0xbe, 0x77, 0x6a, 0x3b, 0x6e, 0x6a, 0x58, 0xdd, 0x84, 0xb2, 0x4b,
	0x59, 0x72, 0x50, 0xe0, 0xb3, 0x24, 0xce, 0x09, 0x6f, 0x80, 0x86, 0x13, 0xf9, 0xc0, 0x1b, 0x5b,
	0xc9, 0xa8, 0x54, 0xcd, 0x7a, 0x88, 0xff, 0x4a, 0x46, 0xe7, 0xcb, 0x00, 0xa7, 0xd4, 0x1e, 0x5a,
	0x42, 0x5b, 0xd1, 0x46, 0x55, 0x8e, 0x11, 0xa1, 0xfe, 0x33, 0xa8, 0xc7, 0xcb, 0xc9, 0xe0, 0x5c,
	0x8d, 0x68, 0xc2, 0x01, 0x70, 0xec, 0xf4, 0x25, 0x17, 0x51, 0x39, 0xca, 0x63, 0xa7, 0x2f, 0x98,
	0xbc, 0x06, 0xb5, 0x68, 0x51, 0xf0, 0x28, 0x8a, 0x00, 0x0f, 0x29, 0x90, 0xc5, 0x1d, 0xa8, 0xca,
	0x20, 0xb4, 0xc6, 0x4e, 0x20, 0x2a, 0x87, 0x6a, 0x56, 0x24, 0xee, 0xb1, 0x13, 0x30, 0xe3, 0x55,
	0x58, 0xed, 0xe1, 0xc0, 0x99, 0x28, 0x8d, 0x8b, 0x99, 0x68, 0xec, 0xc3, 0x4b, 0xfb, 0x94, 0x21,
	0xdf, 0xdd, 0xf3, 0x9f, 0x20, 0x16, 0x03, 0xf3, 0x64, 0x3a, 0xa6, 0x4c, 0x14, 0xf9, 0xb2, 0x19,
	0xc1, 0xc6, 0x13, 0xb8, 0x11, 0x33, 0xea, 0x60, 0xe2, 0x84, 0xac, 0xe2, 0xbc, 0x52, 0x52, 0x79,
	0xf5, 0x3c, 0x76, 0x9f, 0xc0, 0xea, 0xe7, 0xbe, 0xf7, 0x3b, 0xea, 0xee, 0xda, 0x63, 0xdb, 0x1d,
	0x60, 0x8c, 0x8a, 0x12, 0x88, 0x4c, 0x14, 0x53, 0x42, 0x59, 0xd3, 0x8e, 0xf1, 0x9d, 0x0a, 0xa5,
	0xd6, 0x60, 0x10, 0xae, 0x27, 0x9c, 0x8e, 0xff, 0x3c, 0xa1, 0xfb, 0x82, 0xad, 0x1c, 0xbf, 0x43,
	0x90, 0x47, 0xfc, 0xc0, 0xa7, 0x36, 0xa3, 0xe2, 0x52, 0x23, 0x07, 0x25, 0x81, 0xc2, 0x5b, 0xcd,
	0xbb, 0xc0, 0x93, 0x59, 0x5c, 0x9b, 0xc4, 0x3d, 0x65, 0x23, 0xaa, 0xed, 0x28, 0x70, 0x7b, 0xdf,
	0x0e, 0xc4, 0x5d, 0x65, 0x24, 0x7e, 0xf8, 0x16, 0x3e, 0xd1, 0xe3, 0x96, 0x42, 0xe6, 0x16, 0xb3,
	0xf5, 0x44, 0x6c, 0xf1, 0xed, 0x09, 0x6e, 0x69, 0x41, 0x65, 0x4a, 0xfd, 0x89, 0x13, 0x04, 0x89,
	0x26, 0xf2, 0xca, 0xc2, 0xae, 0xa3, 0x98, 0x42, 0xdc, 0x03, 0x92, 0x7b, 0xc8, 0x0e, 0x14, 0x47,
	0xbe, 0x37, 0x9b, 0x86, 0x03, 0x98, 0xbe, 0xa8, 0x26, 0x2e, 0x8a, 0x8d, 0x92, 0x92, 0x7c, 0x06,
	0xf5, 0x13, 0x34, 0xba, 0x25, 0xed, 0x21, 0xfa, 0x4b, 0x65, 0x67, 0x5d, 0x6e, 0x4e, 0xb9, 0xc4,
	0xac, 0x9d, 0x24, 0xc1, 0x40, 0xff, 0x39, 0xc0, 0xd1, 0x98, 0x0e, 0x47, 0x78, 0x4d, 0xe4, 0x46,
	0x9e, 0x22, 0xe4, 0x87, 0x09, 0x27, 0xc1, 0x84, 0x2b, 0x73, 0x49, 0x57, 0xea, 0x3f, 0x2a, 0x50,
	0x92, 0xd6, 0x23, 0xaf, 0xc2, 0xea, 0x60, 0xe6, 0x63, 0x23, 0x60, 0x1e, 0xb3, 0xc7, 0xd2, 0xeb,
	0x55, 0x89, 0xec, 0x71, 0x1c, 0xcf, 0x5c, 0xac, 0x71, 0x27, 0xd4, 0xb7, 0xfb, 0x63, 0x6a, 0x8d,
	0xec, 0x40, 0xb2, 0xac, 0x27, 0xf1, 0xfb, 0x76, 0x80, 0x23, 0x08, 0x8a, 0x47, 0x22, 0xd1, 0xe3,
	0x55, 0x81, 0xe1, 0xcb, 0xaf, 0x43, 0xcd, 0x71, 0xb9, 0x9b, 0x03, 0x6a, 0x05, 0x53, 0x4a, 0x87,
	0xb2, 0xd3, 0xaf, 0x86, 0xd8, 0x2e, 0x47, 0xf2, 0x76, 0x9f, 0x9c, 0x82, 0x05, 0x40, 0x3e, 0x85,
	0xaa, 0xe0, 0x34, 0x14, 0x4e, 0x16, 0xee, 0xda, 0x5c, 0x74, 0x57, 0x64, 0x1a, 0xb3, 0x22, 0xc9,
	0x39, 0xa0, 0xdf, 0x85, 0x92, 0xf4, 0x3f, 0xef, 0xc5, 0xf6, 0x53, 0xdb, 0x19, 0x73, 0xa5, 0x65,
	0xae, 0xc4, 0x08, 0xdd, 0x85, 0x95, 0x03, 0x46, 0x27, 0x4b, 0x37, 0xfd, 0x2d, 0xa8, 0x38, 0x01,
	0x9f, 0xac, 0xac, 0xa9, 0xed, 0xf8, 0x32, 0x93, 0x54, 0x27, 0x78, 0x44, 0xcf, 0x8f, 0x6c, 0x07,
	0xcd, 0xfd, 0x8c, 0x3a, 0xa3, 0x53, 0x26, 0xc3, 0x59, 0x42, 0x7c, 0x2a, 0x8a, 0x03, 0x46, 0x16,
	0xaa, 0x04, 0x46, 0xff, 0x1c, 0x0a, 0x18, 0x24, 0x99, 0x29, 0xf4, 0x06, 0x14, 0x1c, 0x46, 0x27,
	0xdc, 0xde, 0xfc, 0xb0, 0x6b, 0x0b, 0x87, 0xe5, 0x8a, 0x9a, 0x82, 0x42, 0xff, 0xbd, 0x02, 0x10,
	0xc7, 0x6a, 0x26, 0xb7, 0x8d, 0x28, 0x58, 0x73, 0x58, 0xc7, 0xc2, 0x80, 0x8c, 0xa4, 0xe4, 0x7f,
	0x4a, 0x0a, 0xb7, 0x1d, 0xef, 0x5a, 0xc1, 0xa9, 0x37, 0x16, 0xce, 0xcb, 0x9b, 0x31, 0x42, 0xff,
	0x06, 0xb4, 0xc5, 0x74, 0xc9, 0xb8, 0x73, 0x36, 0x93, 0x77, 0xce, 0x0c, 0x0f, 0x46, 0x1c, 0x92,
	0xd7, 0xd1, 0x43, 0xa8, 0x24, 0x72, 0x29, 0x83, 0xeb, 0x9b, 0x69, 0xae, 0xeb, 0x59, 0x89, 0x98,
	0x60, 0x68, 0x7c, 0x09, 0xd7, 0xf7, 0x29, 0x93, 0xcb, 0x89, 0x72, 0xbc, 0x64, 0xb5, 0x7b, 0xa0,
	0xf5, 0xcf, 0xad, 0xb1, 0xe7, 0x8e, 0x68, 0xc0, 0xac, 0x01, 0xef, 0x79, 0xd2, 0xfb, 0xb5, 0xfe,
	0xf9, 0x63, 0x81, 0xc6, 0x4e, 0x68, 0xfc, 0xa8, 0x40, 0x79, 0x2f, 0x7c, 0xda, 0xc8, 0x78, 0x5c,
	0xc2, 0xd7, 0x02, 0xf9, 0xb8, 0xc4, 0xff, 0x79, 0x69, 0x1e, 0xdb, 0xee, 0x68, 0x26, 0x1e, 0x21,
	0xf0, 0x5e, 0x1d, 0xc2, 0xc9, 0xe1, 0x4d, 0x04, 0x4d, 0x34, 0xbc, 0xdd, 0x85, 0x15, 0xbb, 0xef,
	0x04, 0x8d, 0x42, 0xca, 0x5b, 0xa1, 0xe0, 0xed, 0xd6, 0xee, 0x81, 0x89, 0x04, 0xfa, 0x10, 0xf2,
	0xad, 0xdd, 0x83, 0xcc, 0x43, 0x11, 0x58, 0xb1, 0xfd, 0x51, 0x18, 0x08, 0xf8, 0xbf, 0x34, 0x26,
	0xe7, 0x5f, 0x68, 0x4c, 0x36, 0x3a, 0x40, 0xf6, 0x29, 0x0b, 0xc5, 0x87, 0x96, 0x5c, 0x3c, 0xfe,
	0x8b, 0x5b, 0xf1, 0x12, 0x36, 0x13, 0xfc, 0xba, 0xcc, 0xf3, 0xed, 0x11, 0xbd, 0x8a, 0xad, 0x8c,
	0x83, 0x5c, 0xea, 0x45, 0xe3, 0xc4, 0xa1, 0xe3, 0xa1, 0x34, 0xa8, 0x00, 0x32, 0xc5, 0xaf, 0x64,
	0x8a, 0x7f, 0x07, 0xf4, 0x2c, 0xf1, 0x72, 0xc0, 0x09, 0xdf, 0xa3, 0x94, 0xc4, 0x7b, 0xd4, 0xdb,
	0x70, 0xa3, 0x4b, 0xdd, 0x61, 0xd6, 0xf5, 0x34, 0x6b, 0x16, 0xf0, 0xb1, 0x85, 0xf7, 0xbc, 0xb3,
	0xb8, 0xc4, 0x87, 0xe4, 0x89, 0x8e, 0xa9, 0xa4, 0x3b, 0x66, 0x46, 0xcf, 0xc8, 0xbd, 0x78, 0xcf,
	0x30, 0x7c, 0xd8, 0x58, 0x92, 0x29, 0x0c, 0xda, 0xe0, 0x97, 0xa8, 0x41, 0xd4, 0xf1, 0x55, 0x33,
	0x04, 0xe3, 0xd7, 0xbe, 0x5c, 0xf2, 0xb5, 0x2f, 0xcb, 0x90, 0xf9, 0x2c, 0x43, 0xee, 0xfc, 0xa0,
	0x02, 0xb4, 0xa6, 0x4e, 0x97, 0xfa, 0x4f, 0x9d, 0x01, 0x25, 0x5f, 0x42, 0x65, 0x9f, 0xb2, 0xf0,
	0x79, 0x93, 0x84, 0x61, 0x9b, 0x7c, 0x9c, 0xd5, 0x6f, 0x84, 0x8f, 0x91, 0x0b, 0x8f, 0xa0, 0xc6,
	0xfa, 0x1f, 0xfe, 0xfd, 0xbf, 0xbf, 0xe4, 0x6a, 0xa4, 0xda, 0x1c, 0x25, 0x78, 0xf4, 0xa0, 0xca,
	0x5d, 0x15, 0x4e, 0xa1, 0xd9, 0x3c, 0xc3, 0x87, 0xb2, 0xa5, 0x61, 0xd5, 0x78, 0x09, 0x99, 0xd6,
	0xc9, 0x2a, 0x67, 0x1a, 0x73, 0xf9, 0x15, 0x2a, 0xda, 0x9b, 0x8b, 0x41, 0x8d, 0xac, 0x47, 0xcf,
	0x12, 0x89, 0xb9, 0x4d, 0xd7, 0xaf, 0x7e, 0x67, 0x30, 0x6e, 0x22, 0xdf, 0x97, 0xc8, 0x1a, 0xe7,
	0x1b, 0xf2, 0x69, 0x5e, 0x70, 0xe7, 0x5f, 0x92, 0x21, 0xac, 0x23, 0x77, 0x79, 0x2f, 0xda, 0x3d,
	0x17, 0x7c, 0xaf, 0x10, 0xb3, 0xf4, 0x26, 0x62, 0xbc, 0x86, 0xcc, 0xb7, 0xc8, 0x2d, 0xc1, 0x7c,
	0x81, 0x4d, 0x28, 0xc5, 0x83, 0x5a, 0x7a, 0xde, 0x24, 0xb7, 0x24, 0xa7, 0xcc, 0x31, 0x54, 0x5f,
	0xcf, 0xba, 0x3f, 0x18, 0x6f, 0xa0, 0xac, 0x57, 0xc9, 0x1d, 0x2e, 0x2b, 0xb1, 0x4b, 0x4a, 0x69,
	0x5e, 0x84, 0x73, 0xe4, 0x25, 0x79, 0x06, 0xda, 0xe2, 0x5c, 0x4a, 0xb6, 0x96, 0x44, 0xa6, 0x06,
	0xd6, 0x2b, 0x84, 0xbe, 0x8d, 0x42, 0xef, 0x92, 0xd7, 0x13, 0x42, 0xc5, 0xbe, 0xe6, 0x85, 0x98,
	0x68, 0x53, 0x82, 0x29, 0x40, 0x5c, 0xc6, 0x49, 0x23, 0x16, 0x99, 0xae, 0xec, 0x7a, 0x2d, 0xdd,
	0x0f, 0xd2, 0x62, 0x24, 0xb2, 0x79, 0xc1, 0x6b, 0xe3, 0x65, 0xf3, 0x62, 0x31, 0xc2, 0x2f, 0xc9,
	0xb7, 0x0a, 0xd4, 0x17, 0x32, 0x88, 0xbc, 0x1c, 0x0b, 0xcb, 0xc8, 0x2c, 0x7d, 0xeb, 0xaa, 0x65,
	0x79, 0xd0, 0xcf, 0x50, 0x83, 0x0f, 0xc8, 0x03, 0xf4, 0x64, 0x82, 0xa2, 0x79, 0x21, 0x53, 0xf0,
	0xb2, 0x79, 0x81, 0x49, 0x97, 0xa9, 0x51, 0x0f, 0xc3, 0x34, 0x6a, 0x37, 0x9b, 0xb1, 0xb4, 0x85,
	0x52, 0xac, 0xd7, 0x17, 0x3a, 0x84, 0xb1, 0x89, 0x92, 0xd7, 0xc8, 0x75, 0x0c, 0x7c, 0x89, 0x6d,
	0x5e, 0x38, 0xc3, 0x4b, 0x72, 0x9e, 0x2a, 0xe6, 0xb2, 0xfa, 0x91, 0xdb, 0xcb, 0xcc, 0xd3, 0x75,
	0x59, 0xbf, 0xf3, 0x1c, 0x0a, 0x79, 0xde, 0x2d, 0x94, 0xda, 0x30, 0xd6, 0x92, 0x52, 0x25, 0xd1,
	0xc7, 0xca, 0x9b, 0xe4, 0xd7, 0x50, 0x5f, 0x28, 0xa3, 0xd1, 0xa1, 0x96, 0x1f, 0xa0, 0x22, 0xeb,
	0x5e, 0x51, 0x79, 0x0d, 0x82, 0xd2, 0xaa, 0x46, 0xa9, 0x19, 0x70, 0x8a, 0x39, 0x97, 0x60, 0x42,
	0xbd, 0x3d, 0xa7, 0x83, 0x17, 0x94, 0xb0, 0x9c, 0x7b, 0x31, 0x4f, 0xca, 0xd9, 0x70, 0x9e, 0xbb,
	0xda, 0x3f, 0xbf, 0xdf, 0x52, 0xfe, 0xf5, 0xfd, 0x96, 0xf2, 0xdf, 0xef, 0xb7, 0x94, 0xbf, 0xfe,
	0xb0, 0x75, 0xad, 0x5f, 0xc4, 0xeb, 0xec, 0xfd, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0x09, 0x9e,
	0x76, 0x83, 0xb1, 0x1a, 0x00, 0x00,
}
